<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#000000">
<link rel="icon" href="icons/icon-192.png">
<link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192.png">
<link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512.png">
<!-- 画面幅固定＋ユーザズーム禁止） -->
<meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<!-- 電話番号の自動リンク無効化 -->
<meta name="format-detection" content="telephone=no">
<title>ガチャ結果ビューア v21</title>

<!-- 先にライブラリ（ローカル） -->
<script src="/lib/jszip.min.js"></script>
<script src="/lib/pako.min.js"></script>

<!-- もしローカルに無ければ CDN で補う（任意） -->
<script>
(function ensureLibs(){
  function need(src){ return !document.querySelector(`script[src="${src}"]`); }
  function inject(src){ return new Promise((ok,ng)=>{ const s=document.createElement('script'); s.src=src; s.onload=ok; s.onerror=()=>ng(new Error('load '+src)); document.head.appendChild(s); });}
  (async()=>{
    if (typeof JSZip==='undefined') await inject('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
    if (typeof pako==='undefined')  await inject('https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js');
  })();
})();
</script>

<script src="imp_exp_file.js"></script>

<style>
  :root{
    --bg:#0b0b0f;--panel:#15151b;--panel-2:#1b1b22;--text:#f5f5f6;--muted:#b3b3bd;
    --accent:#e11d48;--accent-2:#9f1239;--border:#2a2a36;
    --shadow:0 6px 24px rgba(0,0,0,.35),0 2px 8px rgba(0,0,0,.5)
  }
  *{box-sizing:border-box}html,body{height:100%}
  body{
    margin:0;background:
      radial-gradient(1200px 600px at 20% -10%, rgba(225,29,72,.08), transparent 60%),
      radial-gradient(800px 500px at 100% 0%, rgba(225,29,72,.08), transparent 55%),
      var(--bg);
    color:var(--text);
    font-family:ui-sans-serif,-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Noto Sans JP",Meiryo,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    line-height:1.6
  }
  h1,h2,h3{margin:0 0 .5rem}h1{font-size:1.7rem}h2{font-size:1.2rem}
  .container{max-width:1200px;margin:24px auto 64px;padding:0 16px}

/* iOS の自動文字拡大を抑止 */
html { -webkit-text-size-adjust: 100%; }

/* クリック系要素でのダブルタップ拡大を抑止（対応ブラウザで有効） */
button, a, [role="button"] {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

/* 入力フォーカス時の“勝手に拡大”回避（iOSは16px未満で拡大が発動）*/
@media (hover: none) and (pointer: coarse) {
  input, select, textarea { font-size: 16px; }
}
  /* Buttons */
  .btn{
    display:inline-flex;align-items:center;justify-content:center;gap:.5rem;
    font-size:1rem;line-height:1;min-height:42px;padding:.7rem 1rem;border-radius:10px;
    appearance:none;border:1px solid var(--accent);
    background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#fff;
    font-weight:700;letter-spacing:.02em;cursor:pointer;box-shadow:var(--shadow);
    transition:transform .05s,filter .2s
  }
  .btn:active{transform:translateY(1px) scale(.995)}
  .btn.subtle{background:var(--panel-2);color:var(--text);border-color:var(--border);font-weight:600}
  .btn.ghost{background:transparent;border:1px solid var(--border);color:var(--muted)}
  .btn.small{min-height:32px;padding:.45rem .7rem;font-size:.9rem}
  .btn[disabled]{opacity:.55;cursor:not-allowed;filter:saturate(.6)}

  .tag{display:inline-flex;align-items:center;gap:.45rem;background:#23232b;border:1px solid var(--border);color:#9aa;font-size:.85rem;padding:.2rem .55rem;border-radius:999px}
  .toolbar{background:linear-gradient(180deg, rgba(225,29,72,.12), rgba(225,29,72,.04) 40%, transparent);border:1px solid var(--border);border-radius:16px;padding:16px;display:grid;gap:12px;box-shadow:var(--shadow)}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .file-drop{display:flex;gap:12px;align-items:center;flex-wrap:wrap;border:2px dashed rgba(225,29,72,.45);border-radius:12px;padding:12px;background:rgba(225,29,72,.06)}
  .file-drop.dragover{background:rgba(225,29,72,.12)}
  input[type="file"]::file-selector-button{appearance:none;border:1px solid var(--accent);background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#fff;padding:.55rem .9rem;border-radius:10px;cursor:pointer;font-weight:700;line-height:1;margin-right:.6rem}
  input[type="file"]{color:var(--muted)}
  select{appearance:none;background:#0f1016;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:.55rem 2rem .55rem .7rem;font-weight:600;line-height:1;min-height:42px;
    background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 20 20" fill="none" stroke="%23b3b3bd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 8 10 12 14 8"/></svg>');
    background-repeat:no-repeat;background-position:right .6rem center;background-size:12px}
  select:focus{outline:2px solid rgba(225,29,72,.4);outline-offset:2px}

  .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:var(--shadow)}
  .grid{display:grid;gap:16px}.two-col{grid-template-columns:1fr}@media(min-width:980px){.two-col{grid-template-columns:1fr 1fr}}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0f1014;padding:.1rem .35rem;border-radius:6px;border:1px solid var(--border);color:#d1d5db}
  .muted{color:var(--muted)}.sep{height:1px;background:var(--border);margin:.75rem 0 1rem}
  .visually-hidden{position:absolute!important;inset:0 auto auto 0;width:1px;height:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}

  /* Tabs + item grid */
  .tabs{display:flex;gap:8px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap}
  .tab{padding:.45rem .75rem;border:1px solid var(--border);border-bottom:none;border-top-left-radius:10px;border-top-right-radius:10px;background:#121218;color:var(--muted);cursor:pointer;user-select:none; touch-action: manipulation; position: relative; }
  .tab.active{background:#191922;color:#fff;border-color:var(--accent)}
  .tab:hover{ background:#1f1f27; color:#fff; border-color: var(--accent); }
  .item-grid{display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(160px,1fr))}
  .item-card{background:var(--panel-2);border:1px solid var(--border);border-radius:14px;padding:10px;display:flex;flex-direction:column;gap:8px;min-height:190px;position:relative}
  .item-thumb{aspect-ratio:1/1;background:#0e0f14;border:1px dashed var(--border);border-radius:10px;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .item-thumb img{width:100%;height:100%;object-fit:contain;display:block}
  .item-code{font-weight:800;font-size:1.15rem;letter-spacing:.03em}
  .rarity{font-weight:700}.rarity.SSR{color:#fde68a}.rarity.SR{color:#a78bfa}.rarity.R{color:#93c5fd}.rarity.N{color:#a7f3d0}.rarity.はずれ{color:#fca5a5}
  .card-actions{display:flex;gap:8px;flex-wrap:wrap}
  .card-actions .btn[data-action="primary"]{width:100%}
  .badge{font-size:.75rem;padding:.1rem .4rem;border-radius:.5rem;border:1px solid var(--border);background:#0e0f14;color:#a6a6b3}
  .flag{position:absolute;top:8px;right:10px;display:flex;gap:6px}
  .flag .skip{border-color:#e11d48;color:#fff;background:linear-gradient(180deg,#e11d48,#9f1239)}

  /* Users panel */
  .user-card{margin-bottom:16px;position:relative}
  .user-header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .user-actions{display:flex;gap:8px;align-items:center}.user-actions .btn.small{min-width:110px}
  .gacha-box{background:var(--panel-2);border:1px dashed var(--border);border-radius:12px;padding:12px}
  .rarity-row{display:grid;grid-template-columns:3.6rem 1fr;column-gap:.6rem;align-items:start;margin-top:.25rem}
  .rarity-label{display:flex;align-items:center;font-weight:800;line-height:1.2;min-height:32px}
  .rarity-items{display:flex;flex-wrap:wrap;gap:.3rem .45rem}
  .item-pill{display:inline-flex;align-items:center;gap:.4rem;padding:.25rem .6rem;border-radius:999px;background:#23232b;border:1px solid var(--border)}
  .item-pill img{width:20px;height:20px;object-fit:contain;border-radius:4px;display:block}
  .item-pill.no-img{justify-content:center;padding:.25rem .8rem}

  /* All modals */
  .modal{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.65);padding:20px;z-index:50}
  .modal.show{display:grid}
  .dialog{width:min(880px,96vw);background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:var(--shadow)}
  .dialog h3{margin:0 0 .5rem}
  .dialog .grid-2{display:grid;gap:12px;grid-template-columns:1fr}@media(min-width:860px){.dialog .grid-2{grid-template-columns:1fr 1fr}}

  /* Start splash */
  .splash{display:grid;place-items:center;min-height:60vh}
  .info-btn{width:26px;height:26px;border-radius:999px;border:1px solid var(--border);background:#0f1016;color:#cbd5e1;display:inline-flex;align-items:center;justify-content:center;font-weight:800;cursor:pointer}
  .hint{color:#a1a1aa;font-size:.95rem}

  /* Paste areas */
  textarea{width:100%;min-height:180px;background:#0f1016;color:#f5f5f6;border:1px solid var(--border);border-radius:12px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  input[type="text"]{width:100%;padding:.6rem .7rem;border-radius:10px;border:1px solid var(--border);background:#0f1016;color:#f5f5f6}

  /* 画像プレビューの収まりを強制（モーダル） */
  #modalPreview{width:100%;height:100%; object-fit:contain;image-rendering:auto;}

  /* ユーザー内訳の個数表示 */
  .item-pill .count{font-weight:700;color:#e5e7eb;margin-left:.15rem;}

  /* タブ右上の×ボタン */
  .tab .close{position:absolute; top:-8px; right:-8px; width:20px; height:20px; display:flex; align-items:center; justify-content:center; border-radius:999px; background:#2a2a36; color:#cbd5e1; border:1px solid var(--border); font-weight:800; cursor:pointer;}
  .tab .close:hover{ background:#e11d48; color:#fff; border-color:#e11d48; }
  .tab { position: relative; }
  .tab .close{opacity: 0; pointer-events: none; transition: opacity .15s ease;}
  .tab:hover .close{ opacity: 1; pointer-events: auto; }

  /* 再設計トグル（スライド式） */
  .toggle{display:inline-flex; align-items:center; gap:.5rem;padding:.2rem .5rem; background:#23232b; border:1px solid var(--border);border-radius:999px;}
  .toggle input.switch{appearance:none; width:44px; height:24px; border-radius:999px;background:#0f1016; border:1px solid var(--border);position:relative; outline:none; cursor:pointer;transition:background .2s,border-color .2s;}
  .toggle input.switch::after{content:""; position:absolute; top:2px; left:2px; width:18px; height:18px;border-radius:50%; background:#9ca3af; transition:left .2s, background .2s;}
  .toggle input.switch:checked{ background:#e11d48; border-color:#e11d48; }
  .toggle input.switch:checked::after{ left:24px; background:#fff; }
  .toggle .label{ font-weight:700; color:#cbd5e1; }

  /* JS が #mainUI に .mobile-views を付与した時だけモバイルUIにする */
  #mainUI.mobile-views { padding-bottom: 98px; } /* ボトムタブ分の余白 */

  #mainUI.mobile-views [data-page]{ display:none; }
  #mainUI.mobile-views[data-view="controls"] #controlsPage{ display:block; }
  #mainUI.mobile-views[data-view="items"]    #itemsPanel{ display:block; }
  #mainUI.mobile-views[data-view="users"]    #usersPanel{ display:block; }
  #mainUI.mobile-views[data-view="riagu"]    #skipPanel { display:block; } /* NEW */

  /* ボトムタブ：通常は非表示、mobile-views 時のみ表示 */
  .mobile-tabs{ display:none; }
  #mainUI.mobile-views .mobile-tabs{
    position: fixed; left: 0; right: 0; bottom: 0; z-index: 60;
    display:flex; gap:8px; padding:10px env(safe-area-inset-right) calc(10px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
    background: rgba(10,10,14,.9); backdrop-filter: blur(6px);
    border-top: 1px solid var(--border);
  }
  #mainUI.mobile-views .mobile-tabs button{
    flex:1 1 0; min-height:56px; border-radius:12px; border:1px solid var(--border);
    background:#15151b; color:#cbd5e1; font-weight:700;
  }
  #mainUI.mobile-views .mobile-tabs button.active{ border-color: var(--accent); color:#fff; }

  /* --- モバイル時：アイテムカードを横長に --- */
  #mainUI.mobile-views #itemGrid{ grid-template-columns: 1fr; gap:12px; }
  #mainUI.mobile-views .item-card{
    /* 2カラムの横長グリッド。左に正方形サムネ、右に情報 */
    display:grid;
    grid-template-columns:110px 1fr;
    grid-template-rows:auto auto auto auto;
    grid-template-areas:
      "thumb flag"    /* ← 右上にバッジ（重ならない専用行） */
      "thumb title"
      "thumb rarity"
      "thumb actions";
    align-items:center;
    gap:8px;
    padding:8px;
    min-height:110px;   /* サムネと高さを合わせる */
  }
  /* サムネ（左） */
  #mainUI.mobile-views .item-card .item-thumb{grid-area:thumb; width:100%; max-width:110px; aspect-ratio:1/1;}

  /* 右上のバッジ行：absolute を解除して専用セルに置く（重なり防止） */
  #mainUI.mobile-views .item-card .flag{ grid-area:flag; position:static !important; justify-self:end; align-self:start; margin:0;}
  #mainUI.mobile-views .item-card .badge{ font-size:.72rem; padding:.05rem .35rem; border-radius:.4rem;}

  /* タイトル（item-code）を省略記号で1行に */
  #mainUI.mobile-views .item-card .item-code{ grid-area:title; font-size:1.05rem; line-height:1.2; margin:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

  /* レアリティの行を少し小さくタイトに */
  #mainUI.mobile-views .item-card > .muted{ grid-area:rarity; margin-top:2px; }
  #mainUI.mobile-views .item-card .rarity{ font-size:.9rem; }

  /* アクション（画像設定 / リアグ）は横並び・コンパクトに */
  #mainUI.mobile-views .item-card .card-actions{ grid-area:actions; display:flex; gap:6px; margin-top:2px;}
  #mainUI.mobile-views .item-card .card-actions .btn{ flex:1 1 0; min-height:36px; padding:.45rem .7rem; font-size:.95rem; border-radius:10px;}
  #mainUI.mobile-views .item-card .card-actions .btn.ghost{ font-size:.9rem;}

  /* 正方形タイル配置：PC 4列 / モバイル 2x2 */
  .start-grid{
    display:grid; gap:12px;
    grid-template-columns: repeat(4, minmax(0,1fr));
  }
  @media (max-width: 900px){
    .start-grid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
  }
  .start-tile{
    position:relative; aspect-ratio:1/1;
    border:1px solid var(--accent); border-radius:16px;
    background:linear-gradient(180deg,var(--accent),var(--accent-2));
    color:#fff;
    box-shadow: var(--shadow);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    gap:6px; cursor:pointer; transition:filter .15s, transform .05s;
  }
  .start-tile .title{ font-weight:800; font-size:1.05rem; color:#fff; }
  .start-tile .sub{ font-size:.85rem; color:#ffe6ec; text-align:center; line-height:1.3 }
  .start-tile .info{
    position:absolute; top:8px; right:8px; width:22px; height:22px;
    border-radius:999px; background:rgba(0,0,0,.28); color:#fff;
    display:flex; align-items:center; justify-content:center; font-weight:800;
    border:1px solid rgba(255,255,255,.25);
  }
  .start-tile:hover{ filter:brightness(1.06); transform:translateY(1px); outline:none; }

    /* PWA（standalone）かつモバイル相当のときだけ適用 */
  @media (display-mode: standalone) and (hover: none) and (pointer: coarse) {

    html, body { overscroll-behavior: none; }

    body {
      background: #000;
      -webkit-text-size-adjust: 100%; /* iOSの自動文字拡大を抑止 */
      overscroll-behavior: none;   /* Androidの引っ張り更新/バウンス抑制（iOSは効果弱） */
    }
  }

  .image-actions .btn{ flex:1 1 0; }
</style>
</head>
<body>
  <div class="container">
    <header style="margin-bottom:16px">
      <h1>ガチャ結果ビューア <span class="tag">黒×赤</span> <span class="tag">v21.2.3</span></h1>
      <div class="muted">開始ボタン → <b>リアルタイム</b> / <b>最終結果貼付</b> / <b>JSON読込</b> を選択。解析後は従来UIにマッピングされます。</div>
    </header>

    <!-- Splash -->
    <section id="splash" class="splash">
      <div class="muted" style="max-width:760px; margin:0 auto 12px">
        <p>このサイトは、他サービスで引いたガチャ結果を<strong>見やすく集計・共有</strong>するビューアです。</p>
        <ul style="margin:.3rem 0 .6rem 1.2rem;line-height:1.5">
          <li>まずは <strong>設定データ</strong>（アイテム一覧）か <strong>最終履歴</strong> を読み込みます。</li>
          <li>外部サイトのエクスポート <code>.txt</code>（base64）や本ツールの <code>.json</code> をそのまま取り込めます。</li>
          <li>途中経過は「リアルタイム入力」からどんどん貼り付け可能。</li>
        </ul>
        <p>迷ったら <strong>「TXTを読み込む」</strong>から始めるのが簡単です。</p>
      </div>
      <button class="btn" id="openStart">開始する</button>
      <div class="hint" style="margin-top:.5rem">※ 後からでもJSON読込は可能です</div>
    </section>

    <!-- Main UI (hidden until start/loaded) -->
    <section id="mainUI" style="display:none">
      <section class="toolbar" id="controlsPage" data-page="controls">
        <div class="row file-drop" id="dropzone mainControls">
          <div class="tag" id="summaryTag">未読込</div>
          <div style="flex:1"></div>

          <div class="toggle"><input type="checkbox" id="hideMiss" class="switch"><span class="label">はずれを隠す</span></div>
          <div class="toggle"><input type="checkbox" id="showCounts" class="switch"><span class="label">獲得数を表示</span></div>
          <div class="toggle"><input type="checkbox" id="showSkipOnly" class="switch"><span class="label">リアグのみを表示</span></div>

          <label for="filterRarity">レア度:</label>
          <select id="filterRarity" class="select"></select>

          <label for="userSearch">ユーザー検索:</label>
          <input id="userSearch" type="text" placeholder="名前で検索..." style="max-width:260px" />

          <button class="btn subtle" id="exportMapBtn">画像マップを書き出し</button>
          <label class="btn ghost" for="importMapInput">画像マップを読み込む</label>
          <input type="file" id="importMapInput" accept="application/json,.json" style="display:none" />
          <button class="btn ghost" id="clearMapBtn">画像マップをリセット</button>

          <button class="btn" id="openLivePaste" title="リアルタイム入力パネルを開く">リアルタイム入力</button>
          <button class="btn" id="openAppend" title="最終履歴を既存ガチャへ追加">履歴を追加する</button>
          
          <!-- 追加: アプリ状態の完全エクスポート / インポート -->
          <button class="btn subtle" id="exportAllBtn" title="画像・動画・音声・履歴・設定を丸ごと書き出し">
            全体エクスポート
          </button>
          <label class="btn ghost" for="importAllInput" title="エクスポートしたZIPから丸ごと復元">
            全体インポート
          </label>
          <input type="file" id="importAllInput" accept=".shimmy,application/x-shimmy" style="display:none" />
        </div>
      </section>

      <div class="grid two-col" style="margin-top:16px">
        <section class="panel" id="itemsPanel" data-page="items">
          <h2 style="margin-bottom:.25rem">アイテム画像の設定</h2>
          <div class="muted" style="margin-bottom:8px">タブでガチャを切替。<span class="kbd">レア度:種類</span>ごとに設定。</div>
          <div class="tabs" id="gachaTabs"></div>
          <div id="itemGrid" class="item-grid"></div>
        </section>

        <section class="panel" id="usersPanel" data-page="users">
          <h2>ユーザーごとの獲得内訳</h2>
          <div class="muted">各ユーザーの右上の<b>保存</b>でZIPを無圧縮出力（品質そのまま）。</div>
          <div class="sep"></div>
          <div class="row" style="align-items:center; margin-bottom:8px">
            <label for="filterGacha">ガチャ絞り込み:</label>
            <select id="filterGacha" class="select"><option value="*">すべて</option></select>
          </div>
          <div id="usersList"></div>
        </section>

        <section class="panel" id="skipPanel" data-page="riagu">
          <h2>リアグ</h2>
          <div class="muted">ここに「リアグ」に設定したアイテムの詳細を表示します。（準備中）</div>
        </section>
      </div>
      
      <!-- モバイル用ボトムナビ -->
      <nav id="mobileTabs" class="mobile-tabs" aria-label="画面切り替え">
        <button type="button" data-view="controls" class="active">設定</button>
        <button type="button" data-view="items">アイテム</button>
        <button type="button" data-view="users">ユーザー</button>
        <button type="button" data-view="riagu">リアグ</button>
      </nav>
    </section>
  </div>

  <!-- Start Modal -->
  <div class="modal" id="startModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="startTitle">
      <h3 id="startTitle">はじめる</h3>

      <!-- 四角いタイル群 -->
      <div class="start-grid">
        <button class="start-tile" id="tileTxt">
          <span class="title">TXTを読み込む</span>
          <span class="sub">外部サイトの<br>base64エクスポート</span>
          <span class="info" title="他サイトでエクスポートした .txt（base64）を選ぶと、設定と履歴をまとめて読み込みます。">i</span>
        </button>

        <button class="start-tile" id="tileJson">
          <span class="title">JSONを読み込む</span>
          <span class="sub">このツール形式</span>
          <span class="info" title="本ツールが出力する gacha_summary.json などを読み込みます。">i</span>
        </button>

        <button class="start-tile" id="tileLive">
          <span class="title">リアルタイム進行</span>
          <span class="sub">設定→逐次貼付</span>
          <span class="info" title="アイテム一覧（設定）を貼り付け→以後、リアルタイムの結果テキストを貼り付けて集計します。">i</span>
        </button>

        <button class="start-tile" id="tileFinal">
          <span class="title">最終履歴を貼付</span>
          <span class="sub">最後に一括反映</span>
          <span class="info" title="最終的に出力された一覧を貼り付け、集計に一括反映します。">i</span>
        </button>
      </div>

      <!-- 隠しファイル入力（JSON / TXT） -->
      <input type="file" id="jsonFile2" accept="application/json,.json" class="visually-hidden" />
      <input type="file" id="txtFileInput" accept=".txt,text/plain" class="visually-hidden" /> 

      <!-- 閉じるボタン -->
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:12px">
        <button class="btn ghost" id="closeStart">閉じる</button>
      </div>
    </div>
  </div>

  <!-- Catalog Paste Modal（リアルタイムの最初のフェーズ） -->
  <div class="modal" id="catalogModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="catTitle">
      <h3 id="catTitle">出現アイテム一覧の貼り付け</h3>
      <div class="muted">形式例：<span class="kbd">No./レアリティ/出現率/景品名</span>（縦並び or タブ区切り）</div>
      <div class="sep"></div>
      <label>ガチャ名</label>
      <input id="catGachaName" type="text" placeholder="例：やみぃガチャ" />
      <div style="height:.5rem"></div>
      <label>テキスト</label>
      <textarea id="catText" placeholder="ここに一覧を貼り付け"></textarea>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px">
        <button class="btn subtle" id="catParse">解析して反映</button>
        <button class="btn ghost" id="catClose">閉じる</button>
      </div>
    </div>
  </div>

  <!-- NEW: 案内モーダル（リアルタイム結果は上部ボタンから） -->
  <div class="modal" id="guideModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
      <h3 id="guideTitle">次のステップ</h3>
      <div class="muted">
        ガチャ結果は画面上部の<strong>「リアルタイム入力」</strong>ボタンを押してペーストしてください。
      </div>
      <div class="sep"></div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="guideOk">分かった</button>
      </div>
    </div>
  </div>

  <!-- Live Paste Panel（随時） -->
  <div class="modal" id="liveModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="liveTitle">
      <h3 id="liveTitle">リアルタイム結果を貼り付け</h3>
      <div class="muted">形式例：<span class="kbd">ガチャ名</span> → <span class="kbd">名前100連</span> → <span class="kbd">【R】C　4個</span>… → <span class="kbd">#なまずつーるず</span></div>
      <div class="sep"></div>
      <textarea id="liveText" placeholder="ここに結果テキストを貼り付け（複数ブロック可）"></textarea>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px">
        <button class="btn subtle" id="liveApply">反映</button>
        <button class="btn ghost" id="liveClose">閉じる</button>
      </div>
    </div>
  </div>

  <!-- Final Paste Modal -->
  <div class="modal" id="finalModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="finalTitle">
      <h3 id="finalTitle">最終的なガチャ履歴の貼り付け</h3>
      <div class="muted">先頭のヘッダ（<span class="kbd">ガチャ / No. 名前 / No. レアリティ 景品名 あたり数</span>）は無視されます。</div>
      <div class="sep"></div>
      <label>ガチャ名（未指定なら「ガチャ」）</label>
      <input id="finalGachaName" type="text" placeholder="例：やみぃガチャ" />
      <div style="height:.5rem"></div>
      <label>テキスト</label>
      <textarea id="finalText" placeholder="ここに最終一覧を貼り付け"></textarea>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px">
        <button class="btn subtle" id="finalParse">解析して反映</button>
        <button class="btn ghost" id="finalClose">閉じる</button>
      </div>
    </div>
  </div>

  <!-- Image modal（既存） -->
  <div class="modal" id="imageModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <h3 id="modalTitle">画像を設定</h3>
      <div class="muted" id="modalSubtitle">対象: <span class="tag" id="modalTarget"></span></div>
      <div class="sep"></div>
      <div class="grid-2">
        <div class="preview-box" style="background:var(--panel-2);border:1px solid var(--border);border-radius:12px;padding:10px;display:grid;grid-template-columns:120px 1fr;gap:12px;align-items:center">
          <div class="thumb" style="width:120px;aspect-ratio:1/1;background:#0e0f14;border:1px dashed var(--border);border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center">
            <img id="modalPreview" alt="プレビュー" />
          </div>
          <div>
            <div class="muted" style="margin-bottom:.25rem">現在の画像</div>
            <div class="tag" id="modalStatus">未設定</div>
          </div>
        </div>
        <div>
          <label for="fileInput">ファイルから選択</label>
          <input id="fileInput" type="file" accept="image/*,video/*,audio/*,.mp4,.mp3" />
          <div style="height:.5rem"></div>
          <label for="urlInput">画像URL（画像/動画/音声）</label>
          <input id="urlInput" type="text" placeholder="https://example.com/image.png" />
          <div style="height:.5rem"></div>
          <div class="image-actions" style="display:flex; gap:8px; margin-top:.25rem">
            <button class="btn" id="applyBtn" style="flex:1 1 0">保存</button>
            <button class="btn ghost" id="closeBtn" style="flex:1 1 0">閉じる</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- NEW: ガチャ削除の確認モーダル -->
  <div class="modal" id="deleteModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="delTitle">
      <h3 id="delTitle">ガチャを削除</h3>
      <div class="muted">以下のガチャを削除します： <span class="tag" id="delTarget"></span><br>このガチャのユーザー集計も削除されます。</div>
      <div class="sep"></div>
      <div class="row" style="justify-content:flex-end;gap:8px">
        <button class="btn ghost" id="delCancel">キャンセル</button>
        <button class="btn" id="delConfirm">削除</button>
      </div>
    </div>
  </div>

  <div class="modal" id="appendModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="appendTitle">
      <h3 id="appendTitle">履歴を追加する</h3>
      <div class="muted">最終的なガチャ履歴のフォーマットを貼り付け。ガチャ名を選択してください。</div>
      <div class="sep"></div>
      <label for="appendGacha">ガチャ名</label>
      <select id="appendGacha" class="select"></select>
      <div style="height:.5rem"></div>
      <label for="appendText">テキスト</label>
      <textarea id="appendText" placeholder="最終履歴を貼り付け"></textarea>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px">
        <button class="btn subtle" id="appendApply">反映</button>
        <button class="btn ghost" id="appendClose">閉じる</button>
      </div>
    </div>
  </div>

  <!-- 保存オプションモーダル：デバイス保存 / Vercel Blob 直送 -->
  <div class="modal" id="saveOptionModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="saveOptTitle">
      <h3 id="saveOptTitle">保存オプション</h3>
      <div class="sep"></div>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button class="btn" id="saveDeviceBtn">デバイスに保存</button>
        <button class="btn subtle" id="uploadBlobBtn">ZIP をアップロード</button>
      </div>
      <div id="uploadResult" class="muted" style="margin-top:10px;display:none">
        <div>URL: <a id="uploadUrlLink" href="#" target="_blank" rel="noopener"></a></div>
        <div class="row" style="margin-top:6px">
          <button class="btn small ghost" id="copyUploadUrlBtn">URLをコピー</button>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:12px">
        <button class="btn ghost" id="saveOptClose">閉じる</button>
      </div>
    </div>
  </div>


<!-- 保存モーダル用モジュール（アップロード関数 + 各ボタンの制御を1か所に集約） -->
  <!-- 保存オプションモーダル：デバイス保存 / Vercel Blob 直送 -->
  <div class="modal" id="saveOptionModal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="saveOptTitle">
      <h3 id="saveOptTitle">保存オプション</h3>
      <div class="sep"></div>
      <!-- 選択肢をカード化（説明つき） -->
      <div class="row" style="gap:12px;flex-wrap:wrap">
        <div style="flex:1 1 320px;min-width:280px;background:var(--panel-2);border:1px solid var(--border);border-radius:12px;padding:12px">
          <div style="font-weight:800;margin-bottom:6px">自分で保存して共有する</div>
          <div class="muted" style="font-size:.95rem;margin-bottom:10px">
            端末にZIPを保存し、後で <b>ギガファイル便</b> などお好みのサービスへアップロードする方法です。
            ストレージや保持期間を自分で管理したい方向け。
          </div>
          <button class="btn" id="saveDeviceBtn">デバイスに保存</button>
        </div>

        <div style="flex:1 1 320px;min-width:280px;background:var(--panel-2);border:1px solid var(--border);border-radius:12px;padding:12px">
          <div style="font-weight:800;margin-bottom:6px">shimmy3.com のアップロード（無料）</div>
          <div class="muted" style="font-size:.95rem;margin-bottom:10px">
            画質・音質の劣化なしでZIPをアップロードし、<b>受け取り専用リンク</b>を発行します。
            すぐに共有したい・手早く渡したい方向け。
          </div>
          <button class="btn subtle" id="uploadBlobBtn">ZIP をアップロード</button>
        </div>
      </div>

      <!-- 長いURLでもはみ出さない表示 -->
      <div id="uploadResult" class="muted" style="margin-top:12px;display:none">
        <div class="row" style="gap:10px;align-items:center">
          <div style="min-width:110px">受け取り用URL</div>
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;flex:1">
            <a id="uploadUrlLink" href="#" target="_blank" rel="noopener"
              style="display:block;padding:8px 10px;background:var(--panel);border:1px solid var(--border);border-radius:8px;
                      font-family:ui-monospace,Menlo,Consolas,monospace;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
              title="">
              <span id="uploadUrlText"></span>
            </a>
            <button class="btn small ghost" id="copyUploadUrlBtn" style="white-space:nowrap">URLをコピー</button>
          </div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:12px">
        <button class="btn ghost" id="saveOptClose">閉じる</button>
      </div>
    </div>
  </div>


<!-- 保存モーダル用モジュール（アップロード関数 + 各ボタンの制御を1か所に集約） -->
<script type="module">
  import { upload } from 'https://esm.sh/@vercel/blob@0.23.4/client';

  // ====== CSRF取得（このモジュール内で完結）======
  let csrfToken = '';
  async function ensureCsrf() {
    if (csrfToken) return csrfToken;
    const r = await fetch(`/api/blob/csrf?ts=${Date.now()}`, {
      credentials: 'same-origin',
      cache: 'no-store'
      });
    const j = await r.json();
    if (!r.ok || !j?.token) throw new Error('CSRF token fetch failed');
    csrfToken = j.token;
    return csrfToken;
  }

  // ====== メタ（ユーザー識別 & 用途）======
  function getUserId() {
    return (window.localStorage.getItem('uid') || 'guest');
  }
  const PURPOSE = 'zips';
  const RECEIVE_TOKEN_TTL_DAYS = 7; // 共有リンクの既定有効期限（必要なら環境に合わせて変更）

  // ====== 受け取り用リンク発行API呼び出し ======
  async function issueReceiveShareUrl({ url, name, purpose = PURPOSE, validUntil }) {
    await ensureCsrf();
    const body = {
      url,
      name,
      purpose,
      validUntil: validUntil || new Date(Date.now() + RECEIVE_TOKEN_TTL_DAYS * 24 * 60 * 60 * 1000).toISOString(),
      csrf: csrfToken
    };
    const res = await fetch('/api/receive/token', {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(body)
    });
    const j = await res.json().catch(()=> ({}));
    if (!res.ok || !j?.ok) {
      const msg = j?.error || `Token API failed (${res.status})`;
      throw new Error(msg);
    }
    // j: { ok:true, token, shareUrl, exp }
    return j;
  }

  // ====== 公開ブリッジ：ZIP Blob を Vercel Blob へ直送 ======
  // 使い方: const put = await window.__vercelBlobUpload(filename, blob)
  window.__vercelBlobUpload = async (filename, blob) => {
    await ensureCsrf();
    const userId = getUserId();
    const put = await upload(filename, blob, {
      access: 'public',
      multipart: true,                 // 100–200MB想定のためmultipartを有効化
      contentType: 'application/zip',
      handleUploadUrl: '/api/blob/upload',
      clientPayload: JSON.stringify({ csrf: csrfToken, userId, purpose: PURPOSE })
    });
    return put; // { url, downloadUrl, pathname, ... }
  };

  // ====== モーダル内UI制御 ======
  const saveOptionModal = document.getElementById('saveOptionModal');
  const closeBtn   = document.getElementById('saveOptClose');
  const saveBtn    = document.getElementById('saveDeviceBtn');
  const uploadBtn  = document.getElementById('uploadBlobBtn');
  const resultBox  = document.getElementById('uploadResult');
  const urlLink    = document.getElementById('uploadUrlLink');
  const urlText    = document.getElementById('uploadUrlText');
  const copyBtn    = document.getElementById('copyUploadUrlBtn');

  // 閉じる
  closeBtn?.addEventListener('click', () => close(saveOptionModal));

  // デバイス保存
  saveBtn?.addEventListener('click', async () => {
    const user = window.__saveTargetUser, gobj = window.__saveTargetGobj;
    if (!user || !gobj) return;

    const old = saveBtn.textContent;
    saveBtn.disabled = true; saveBtn.textContent = '保存準備…';
    try {
      const { blob } = await buildZipForUser(user, gobj);
      const filename = `${sanitize(user)}_gacha.zip`;

      if ('showSaveFilePicker' in window) {
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description:'ZIP archive', accept:{ 'application/zip':['.zip'] } }]
        });
        const w = await handle.createWritable(); await w.write(blob); await w.close();
      } else if (navigator.canShare) {
        const file = new File([blob], filename, { type:'application/zip' });
        if (navigator.canShare({ files:[file] })) {
          await navigator.share({ files:[file], title: filename });
        } else {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = filename;
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        }
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }
    } catch (e) {
      alert('保存に失敗: ' + (e?.message || e));
    } finally {
      saveBtn.disabled = false; saveBtn.textContent = old;
    }
  });

  // ZIPをアップロード → 受け取り用リンク発行 → UI表示
  uploadBtn?.addEventListener('click', async () => {
    const user = window.__saveTargetUser, gobj = window.__saveTargetGobj;
    if (!user || !gobj) return;

    const old = uploadBtn.textContent;
    uploadBtn.disabled = true; uploadBtn.textContent = 'アップロード中…';
    try {
      // 1) ZIP生成
      const { blob } = await buildZipForUser(user, gobj);
      const filename = `${sanitize(user)}_gacha.zip`;

      // 2) Vercel Blobへ直送アップロード
      const put = await window.__vercelBlobUpload(filename, blob);
      const downloadUrl = put.downloadUrl || put.url;
      if (!downloadUrl) throw new Error('upload response has no downloadUrl');

      // 3) 受け取り用リンクを発行（サーバが shareUrl を返す）
      const tokenRes = await issueReceiveShareUrl({
        url: downloadUrl,
        name: filename,
        purpose: PURPOSE
        // validUntil は既定の7日（RECEIVE_TOKEN_TTL_DAYS）をサーバ側で運用/丸め込み
      });
      const shareUrl = tokenRes?.shareUrl || '';
      if (!shareUrl) throw new Error('Token API returned no shareUrl');

      // 4) ユーザー別の最新URLとして保存（以後、一覧の「URLをコピー」で共有リンクをコピー）
      setLastUploadUrl(user, shareUrl);
      renderUsersList();

      // 5) UI反映（受け取り用URLを表示）
      if (resultBox && urlLink) {
        resultBox.style.display = 'block';
        urlLink.href = shareUrl;
        urlLink.title = shareUrl;      // ホバーで全体を確認
        urlText.textContent = shareUrl; // CSSのellipsisで折り返さず省略表示
        if (urlText) urlText.textContent = shareUrl;
        else urlLink.textContent = shareUrl; // ★ フォールバック（#uploadUrlText が無い環境でも表示）
      }
    } catch (e) {
      console.error(e);
      alert('アップロード/共有リンク発行に失敗: ' + (e?.message || e));
    } finally {
      uploadBtn.disabled = false; uploadBtn.textContent = old;
    }
  });

  // URLコピー（受け取り用URLをコピー）
  copyBtn?.addEventListener('click', async () => {
    const url = urlLink?.href || '';
    if (!url) return;
    try {
      await navigator.clipboard.writeText(url);
      copyBtn.textContent = 'コピーしました';
      setTimeout(() => (copyBtn.textContent = 'URLをコピー'), 1200);
    } catch {
      window.prompt('このURLをコピーしてください', url);
    }
  });
</script>

<script>
/* ====== 小ユーティリティ ====== */
const $ = (sel, el=document) => el.querySelector(sel);
const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
const baseRarityOrder = ["UR","SSR","SR","R","N","はずれ"];
let gRarityOrder = [...baseRarityOrder];
const keyOf = (gacha, rarity, code) => `${gacha}::${rarity}::${code}`;
const legacyKey = (rarity, code) => `${rarity}::${code}`;
const stripGacha = (key) => { const p = String(key).split("::"); return p.length===3 ? `${p[1]}::${p[2]}` : key; };
const byRarityThenCode = (a,b)=>{const ra = gRarityOrder.indexOf(a.rarity);const rb = gRarityOrder.indexOf(b.rarity);if(ra !== rb) return ra - rb;return (a.code||'').localeCompare(b.code||'ja');};
const escapeHtml = s => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
const sanitize = s => String(s).replace(/[\\/:*?"<>|]+/g, "_").replace(/\s+/g, "_");
const uniqPush = (arr, v) => { if(!arr.includes(v)) arr.push(v); };

/* ====== 画像保存系（既存） ====== */
let gData = {};                     // { user: { gacha: { pulls:int, items:{rarity:[code...]}}}}
let gCatalogByGacha = {};           // { gacha: [{gacha,rarity,code}, ...]} ← 追加：カタログ定義
let gAllGachas=[], gItemsByGacha={}, selectedGacha=null, currentModalTarget=null;
let gHitCounts = {};

const LS_KEY_IMG="gacha_item_image_map_v1";
const LS_KEY_SKIP="gacha_item_image_skip_v1";
const LS_KEY_ORIG="gacha_item_original_v1";
function loadLocalJSON(key, fallback){ try{ return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }catch(e){ return fallback; } }
function saveLocalJSON(key, value){ try{ localStorage.setItem(key, JSON.stringify(value)); return true; } catch(e){ if(e && (e.name==="QuotaExceededError"||e.code===22)){ console.warn("quota",key); return false; } throw e; } }
let imgMap=loadLocalJSON(LS_KEY_IMG,{}), origMap=loadLocalJSON(LS_KEY_ORIG,{}), skipSet=new Set(loadLocalJSON(LS_KEY_SKIP,[]));
const skipHas=(key)=>skipSet.has(key)||skipSet.has(stripGacha(key));
const skipAdd=(key)=>{ skipSet.add(key); skipSet.delete(stripGacha(key)); saveLocalJSON(LS_KEY_SKIP,Array.from(skipSet)); };
const skipDel=(key)=>{ skipSet.delete(key); skipSet.delete(stripGacha(key)); saveLocalJSON(LS_KEY_SKIP,Array.from(skipSet)); };

const DB_NAME="gachaImagesDB", STORE="images";
function idbOpen(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=e=>{const db=e.target.result;if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE)}; r.onsuccess=e=>res(e.target.result); r.onerror=e=>rej(e.target.error); });}
async function idbPut(key,blob){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).put(blob,key); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error); });}
async function idbGet(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,"readonly"); const rq=tx.objectStore(STORE).get(key); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); });}
async function idbDelete(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).delete(key); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error); });}
async function idbClear(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).clear(); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error); });}
const urlCache=new Map(); async function urlForKey(key){ if(urlCache.has(key)) return urlCache.get(key); const blob=await idbGet(key); if(!blob) return ""; const url=URL.createObjectURL(blob); urlCache.set(key,url); return url; }

function lookupVal(map,key){ if(map[key]) return map[key]; const leg=stripGacha(key); return map[leg]||""; }
function immediateSrcFor(key){ const v=lookupVal(imgMap,key); if(!v) return ""; if(v.startsWith("idb:")) return ""; return v; }
function thumbInnerHTML(it){ const key=keyOf(it.gacha,it.rarity,it.code); const src=immediateSrcFor(key); return src?`<img src="${src}" alt="${escapeHtml(it.code)}" />`:`<span class="muted">No Image</span>`; }

// スプラッシュ中はスクロール不可
document.body.classList.add('splash-locked');

/* ====== JSON 読み込み／UI 再描画 ====== */
function handleFiles(files){ if(!files||!files.length) return; const f=files[0]; const rd=new FileReader(); rd.onload=()=>{ try{ onJsonLoaded(JSON.parse(rd.result)); startDone(); }catch(err){ alert("JSONの解析に失敗: "+err.message);} }; rd.readAsText(f,"utf-8"); }

const drop=$("#dropzone");
if (drop) {
  drop.addEventListener("dragover",(e)=>{e.preventDefault();drop.classList.add("dragover")});
  drop.addEventListener("dragleave",()=>drop.classList.remove("dragover"));
  drop.addEventListener("drop",(e)=>{e.preventDefault();drop.classList.remove("dragover");handleFiles(e.dataTransfer.files)});
}
$("#loadJsonBtn")?.addEventListener("click",()=>handleFiles($("#jsonFile").files));

// ---- mobile 判定 & 切替（mainUI を安全に取得してから動かす） ----
let __mainUI = null;
function getMainUI(){ return __mainUI || (__mainUI = document.getElementById('mainUI')); }

// “モバイル相当”を環境と幅の両面で判定
function isMobileLike(){
  return window.matchMedia('(max-width: 900px), (hover: none) and (pointer: coarse)').matches;
}

function syncMobileTabs(){
  const main = getMainUI(); if(!main) return;
  const view = main.getAttribute('data-view') || 'controls';
  document.querySelectorAll('#mobileTabs button').forEach(b=>{
    b.classList.toggle('active', b.getAttribute('data-view') === view);
  });
}

// 自動保存関係
const LS_KEY_APP = "gacha_app_state_v1";
function saveAppState(){
  try{
    const state = {
      data: gData,
      catalogs: gCatalogByGacha,
      counts: gHitCounts,
      selected: selectedGacha || null,
    };
    localStorage.setItem(LS_KEY_APP, JSON.stringify(state));
  }catch(e){ console.warn("saveAppState failed:", e); }
}

function saveAppStateDebounced(){
  clearTimeout(saveAppStateDebounced._t);
  saveAppStateDebounced._t = setTimeout(saveAppState, 150);
}

function loadAppState(){
  try{
    const raw = localStorage.getItem(LS_KEY_APP);
    if(!raw) return false;
    const s = JSON.parse(raw);
    gData = s?.data || {};
    gCatalogByGacha = s?.catalogs || {};
    gHitCounts = s?.counts || {};
    selectedGacha = s?.selected || selectedGacha;
    return true;
  }catch(e){ console.warn("loadAppState failed:", e); return false; }
}

function updateMobileViewMode(){
  const main = getMainUI();        // ← ここで取得（まだ無ければ何もしない）
  if (!main) return;
  const mobile = isMobileLike();
  if (mobile) {
    main.classList.add('mobile-views');
    if (!main.getAttribute('data-view')) main.setAttribute('data-view','controls'); // ← 既定を「設定」
  } else {
    main.classList.remove('mobile-views');
    main.removeAttribute('data-view');
  }
  syncMobileTabs();
}

document.addEventListener('DOMContentLoaded', () => {
  if (loadAppState()) {
    rebuildGachaCaches();
    renderTabs();
    renderItemGrid();
    renderUsersList();
    startDone();
    saveAppStateDebounced();               // スプラッシュを閉じて通常画面へ
  }
});

// DOM 構築後に初回実行（早すぎる呼び出しを防止）
document.addEventListener('DOMContentLoaded', updateMobileViewMode);
window.addEventListener('resize', updateMobileViewMode);
window.addEventListener('orientationchange', updateMobileViewMode);

// 画面が開かれた際、閉じられた際にも保存
window.addEventListener('beforeunload', saveAppState);
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveAppState(); });

$$(".modal").forEach(m=>{
  m.addEventListener("touchmove", e=>{ if(e.target === m) e.preventDefault(); }, {passive:false});
});

$("#mobileTabs")?.addEventListener("click", (e)=>{
  const b = e.target.closest('button[data-view]'); if(!b) return;
  const view = b.getAttribute('data-view');
  mainUI.setAttribute('data-view', view);
  $$("#mobileTabs button").forEach(x=>x.classList.toggle('active', x===b));
  // スクロール位置を上に
  syncMobileTabs();
  window.scrollTo({top:0, behavior:'smooth'});
});

function incCount(user, gacha, rarity, code, by=1){
  if(!user || !gacha || !rarity || !code) return;
  gHitCounts[user] = gHitCounts[user] || {};
  gHitCounts[user][gacha] = gHitCounts[user][gacha] || {};
  gHitCounts[user][gacha][rarity] = gHitCounts[user][gacha][rarity] || {};
  gHitCounts[user][gacha][rarity][code] = (gHitCounts[user][gacha][rarity][code] || 0) + (by||0);
}

function onJsonLoaded(data){
  gData = data || {};
  rebuildGachaCaches();
  renderTabs();
  renderItemGrid();
  renderUsersList();
  saveAppStateDebounced();
}

function rebuildGachaCaches(){
  // gItemsByGacha: gData 由来のアイテム
  const perGachaMap = {};
  let usersCount=0, gachaEntries=0, itemUniqueTotal=0;

  Object.entries(gData).forEach(([user,gobj])=>{
    usersCount++;
    Object.entries(gobj).forEach(([gacha,info])=>{
      gachaEntries++;
      if(!perGachaMap[gacha]) perGachaMap[gacha]=new Map();
      Object.entries(info.items||{}).forEach(([rarity,arr])=>{
        (arr||[]).forEach(code=>{
          const k=keyOf(gacha,rarity,code);
          if(!perGachaMap[gacha].has(k)) perGachaMap[gacha].set(k,{gacha,rarity,code});
        });
      });
    });
  });

  // まず全レアリティを収集（データ＋カタログ）
  const raritySet = new Set();
  Object.values(perGachaMap).forEach(map => map.forEach(it => raritySet.add(it.rarity)));
  Object.values(gCatalogByGacha).forEach(arr => (arr||[]).forEach(it => raritySet.add(it.rarity)));

  // ★ 動的レアリティ順を決定：基本順 → 未知はアルファベット順で後置
  const customRarities = Array.from(raritySet).filter(r => !baseRarityOrder.includes(r)).sort((a,b)=>a.localeCompare(b,'ja'));
  gRarityOrder = [
    ...baseRarityOrder.filter(r => raritySet.has(r)),
    ...customRarities,
  ];

  // gItemsByGacha を作成（並びは gRarityOrder に従う）
  const gSet = new Set([...Object.keys(perGachaMap), ...Object.keys(gCatalogByGacha)]);
  gItemsByGacha = {};
  gSet.forEach(g=>{
    const fromData = Array.from(perGachaMap[g]?.values()||[]);
    const fromCat  = Array.from((gCatalogByGacha[g]||[]).values());
    const map = new Map();
    [...fromData, ...fromCat].forEach(it=>map.set(keyOf(it.gacha,it.rarity,it.code), it));
    const arr = Array.from(map.values()).sort(byRarityThenCode);
    gItemsByGacha[g] = arr;
    itemUniqueTotal += arr.length;
  });
  gAllGachas = Array.from(gSet);

  if(!selectedGacha) selectedGacha = gAllGachas[0] || null;

  // 概要
  $("#summaryTag").textContent = `${Object.keys(gData).length}ユーザー / ${gSet.size}ガチャ / ${itemUniqueTotal}アイテム`;

  // ガチャ絞り込みセレクト更新
  const selG=$("#filterGacha");
  if(selG) selG.innerHTML='<option value="*">すべて</option>'+gAllGachas.map(g=>`<option>${g}</option>`).join("");

  // ★ レアリティセレクトも動的に更新
  const selR=$("#filterRarity");
  if(selR){
    selR.innerHTML = '<option value="*">すべて</option>' + gRarityOrder.map(r=>`<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join("");
  }
}

function renderTabs(){
  const tabs=$("#gachaTabs"); if(!tabs) return;
  tabs.innerHTML="";
  gAllGachas.forEach((g,idx)=>{
    const el=document.createElement("div");
    el.className="tab"+((selectedGacha?selectedGacha===g:idx===0)?" active":"");
    el.textContent=g; el.dataset.gacha=g;
    el.addEventListener("click",()=>{ selectedGacha=g; $$(".tab",tabs).forEach(t=>t.classList.toggle("active",t.dataset.gacha===g)); renderItemGrid(); });
        // 右上 × ボタン
    const x=document.createElement("button");
    x.type="button";
    x.className="close";
    x.textContent="×";
    x.title="このガチャを削除";
    x.addEventListener("click",(ev)=>{
      ev.stopPropagation();
      openDeleteConfirm(g);
    });
    el.appendChild(x);

    tabs.appendChild(el);
  });

  // ＋ボタン：新しいガチャを追加（開始モーダルを開く）
  const add=document.createElement("div");
  add.className="tab add";
  add.title="ガチャの種類を追加";
  add.textContent="＋";
  add.style.fontWeight="800";
  add.style.borderStyle="solid";
  add.addEventListener("click", ()=> open(startModal));
  tabs.appendChild(add);

  if(!selectedGacha && gAllGachas.length) selectedGacha=gAllGachas[0];
}

function renderItemGrid(){
  const grid=$("#itemGrid"); if(!grid){ return; }
  grid.innerHTML="";
  if(!selectedGacha){ grid.textContent="ガチャがありません。開始メニューから定義またはJSONを読み込んでください。"; return; }
  const rFilter=$("#filterRarity").value;
  const list=(gItemsByGacha[selectedGacha]||[]).filter(it=>rFilter==="*"||it.rarity===rFilter);
  for(const it of list){
    const key=keyOf(it.gacha,it.rarity,it.code);
    const skipped=skipHas(key);
    const hasImage=!!lookupVal(imgMap,key);
    const card=document.createElement("div"); card.className="item-card";
    card.innerHTML=`
      <div class="item-thumb" data-thumb-key="${key}">${thumbInnerHTML(it)}</div>
      <div class="item-code">${escapeHtml(it.code)}</div>
      <div class="muted"><span class="rarity ${it.rarity}">${it.rarity}</span></div>
      <div class="card-actions">
        <button class="btn" data-action="primary"${skipped?' disabled':''}>${hasImage?'解除':'画像設定'}</button>
        <button class="btn ghost" data-action="skip">${skipped?"リアグ解除":"リアグ"}</button>
      </div>
      <div class="flag"><span class="badge">${it.gacha} / ${it.rarity}:${escapeHtml(it.code)}</span>${skipped?'<span class="badge skip">リアグ</span>':""}</div>`;
    card.querySelector('[data-action="primary"]').addEventListener("click",()=>{ const nowHas=!!lookupVal(imgMap,key); if(nowHas){ clearImage(it); } else { openImageModal(it); }});
    card.querySelector('[data-action="skip"]').addEventListener("click",()=>toggleSkip(it));
    grid.appendChild(card);
  }
  resolveThumbs(grid);
}

// 目的: ユーザー一覧の描画。保存ボタンは保存オプションモーダルを開く。既存のURLがあれば「URLをコピー」を出す。
function renderUsersList(){
  const wrap=$("#usersList"); if(!wrap) return;
  wrap.innerHTML="";
  const empty = Object.keys(gData).length===0;
  if(empty){ wrap.innerHTML='<div class="muted">まだユーザー履歴がありません。開始メニューまたはリアルタイム入力から反映してください。</div>'; return; }

  const gachaFilter=$("#filterGacha").value, rFilter=$("#filterRarity").value, hideMiss=$("#hideMiss").checked, q=($("#userSearch").value||"").trim();
  const showCounts = $("#showCounts")?.checked;
  const showSkipOnly = $("#showSkipOnly")?.checked;
  
  Object.entries(gData).forEach(([user,gobj])=>{
    if(q && !user.includes(q)) return;

    const card=document.createElement("div"); card.className="user-card panel";
    const header=document.createElement("div"); header.className="user-header";

    const lastUrl = (typeof gLastUploadUrls!=="undefined") ? gLastUploadUrls[user] : "";
    header.innerHTML = `<h2>${escapeHtml(user)}</h2>
      <div class="user-actions">
        <button class="btn small" data-zip-save>保存</button>
        ${lastUrl ? `<button class="btn small ghost" data-copy-url>URLをコピー</button>` : ``}
      </div>`;
    card.appendChild(header);

    // 保存ボタン → 保存オプションモーダルを開く
    header.querySelector('[data-zip-save]')?.addEventListener('click', ()=>{
      // モーダルに対象ユーザー情報をセット
      window.__saveTargetUser = user;
      window.__saveTargetGobj = gobj;
      // 前回の結果表示をリセット
      const ur = document.getElementById('uploadResult');
      const link = document.getElementById('uploadUrlLink');
      if (ur){ ur.style.display='none'; }
      if (link){ link.textContent=''; link.href='#'; }
      // モーダルを開く
      open(document.getElementById('saveOptionModal'));
    });

    // 既存URLがある場合はコピー機能
    const copyBtn = header.querySelector('[data-copy-url]');
    if (copyBtn){
      copyBtn.addEventListener('click', async ()=>{
        const u = gLastUploadUrls[user]; if(!u) return;
        try{ await navigator.clipboard.writeText(u); copyBtn.textContent='コピー済み'; setTimeout(()=>copyBtn.textContent='URLをコピー',1200); }
        catch{ prompt('URL をコピーしてください', u); }
      });
    }
    
    let hasAnyBox = false; 
    Object.entries(gobj).forEach(([gacha,info])=>{
      if(gachaFilter!=="*" && gachaFilter!==gacha) return;
      const box=document.createElement("div"); box.className="gacha-box";
      const pulls=info.pulls??0; box.innerHTML=`<div><strong>${escapeHtml(gacha)}</strong> <span class="tag">${pulls}連</span></div>`;
      const items=info.items||{};
      let boxHasAny = false;
      
      gRarityOrder.forEach(rarity=>{
        let list = (items[rarity] || []);
        if(showSkipOnly){
          list = list.filter(code => skipHas(keyOf(gacha, rarity, code)));
        }
        if(!list.length) return; 
        if(hideMiss && rarity==="はずれ") return; 
        if(rFilter!=="*" && rFilter!==rarity) return;

        const row=document.createElement("div"); row.className="rarity-row";
        const label=document.createElement("span"); label.className=`rarity-label rarity ${rarity}`; label.textContent=rarity;
        const itemsWrap=document.createElement("div"); itemsWrap.className="rarity-items";

        list.forEach(code=>{
          const key=keyOf(gacha,rarity,code);
          const pill=document.createElement("span");
          const v=lookupVal(imgMap,key);
          const immediate=v && !v.startsWith("idb:") ? v : "";
          const countVal = showCounts ? (((gHitCounts[user]||{})[gacha]||{})[rarity]||{})[code] : null;

          pill.className="item-pill"+(immediate?"":" no-img");
          pill.dataset.imgKey = key;
          pill.dataset.user  = user;
          pill.dataset.gacha = gacha;
          pill.dataset.rarity= rarity;
          pill.dataset.code  = code;

          const labelHtml = `<span>${escapeHtml(code)}</span>${(countVal!=null)?`<span class="count">×${countVal}</span>`:""}`;

          if(immediate){
            pill.innerHTML=`<img alt="${escapeHtml(code)}" src="${immediate}"/>${labelHtml}`;
          }else{
            pill.innerHTML=labelHtml;
          }
          itemsWrap.appendChild(pill);
        });

        if(itemsWrap.children.length){
          row.appendChild(label); row.appendChild(itemsWrap); box.appendChild(row);
          boxHasAny = true;
        }
      });
      if(boxHasAny){ card.appendChild(box); hasAnyBox = true; }
    });

    if(hasAnyBox){ wrap.appendChild(card); } // 対象がないユーザーは出さない
  });
  resolvePills(wrap);
}
  
// 目的: アップロードURLの保持/復元（ユーザー単位）
const LS_KEY_UPLOAD_URLS = "last_upload_urls_v1";
let gLastUploadUrls = loadLocalJSON(LS_KEY_UPLOAD_URLS, {});
function setLastUploadUrl(user, url){
  gLastUploadUrls[user] = url;
  saveLocalJSON(LS_KEY_UPLOAD_URLS, gLastUploadUrls);
}
  

/* ====== 履歴を追加モーダル ====== */
const appendModal = $("#appendModal");

$("#openAppend").addEventListener("click", ()=>{
  const sel = $("#appendGacha");
  sel.innerHTML = gAllGachas.map(g=>`<option>${g}</option>`).join("");
  open(appendModal);
});
$("#appendClose").addEventListener("click", ()=>close(appendModal));

$("#appendApply").addEventListener("click", ()=>{
  const gacha = ($("#appendGacha").value||"").trim();
  const text  = ($("#appendText").value||"").trim();
  if(!gacha){ alert("ガチャ名を選択してください。"); return; }
  if(!text){ alert("テキストを貼り付けてください。"); return; }

  const parsed = parseFinalSummaryText(text);
  if(parsed.length===0){ alert("ユーザーの成績を検出できませんでした。"); return; }

  const delta = {}, catSet = new Map();
  parsed.forEach(({user, entries})=>{
    delta[user] = delta[user] || {};
    delta[user][gacha] = delta[user][gacha] || {pulls:0, items:{}};
    let pulls = 0;
    entries.forEach(({rarity, code, count})=>{
      pulls += (+count||0);
      delta[user][gacha].items[rarity] = delta[user][gacha].items[rarity] || [];
      uniqPush(delta[user][gacha].items[rarity], code);
      catSet.set(keyOf(gacha,rarity,code), {gacha,rarity,code});
      incCount(user, gacha, rarity, code, +count||0); // 獲得数も反映
    });
    delta[user][gacha].pulls += pulls;
  });

  gCatalogByGacha[gacha] = Array.from(catSet.values()).sort(byRarityThenCode);
  mergeIntoGData(delta);

  rebuildGachaCaches(); renderTabs(); renderItemGrid(); renderUsersList();
  close(appendModal);
  saveAppStateDebounced();
});

/* ====== ガチャタブ削除確認モーダル ====== */
const deleteModal = $("#deleteModal");
let pendingDeleteGacha = null;

function openDeleteConfirm(gacha){
  pendingDeleteGacha = gacha;
  $("#delTarget").textContent = gacha;
  open(deleteModal);
}
$("#delCancel").addEventListener("click", ()=>{ pendingDeleteGacha=null; close(deleteModal); });
$("#delConfirm").addEventListener("click", ()=>{
  const g = pendingDeleteGacha; pendingDeleteGacha=null; close(deleteModal);
  if(!g) return;
  // カタログから削除
  delete gCatalogByGacha[g];
  // 集計から削除 & カウントも削除
  for(const user of Object.keys(gData)){
    if(gData[user] && gData[user][g]) delete gData[user][g];
    if(gHitCounts[user] && gHitCounts[user][g]) delete gHitCounts[user][g];
    // ユーザーの全ガチャが無くなったら空を掃除
    if(gData[user] && Object.keys(gData[user]).length===0) delete gData[user];
  }
  // 選択ガチャの調整
  if(selectedGacha === g) selectedGacha = null;
  rebuildGachaCaches();
  renderTabs(); renderItemGrid(); renderUsersList(); saveAppStateDebounced();
});

/* ====== 画像モーダル（既存） ====== */
const imageModal=$("#imageModal"); let tempPreviewURL="";
function openImageModal(it){
  const k=keyOf(it.gacha,it.rarity,it.code); if(skipHas(k)) return;
  currentModalTarget=it; $("#modalTarget").textContent=`${it.gacha} / ${it.rarity}:${it.code}`;
  const cur=immediateSrcFor(k); $("#modalPreview").src=cur||""; $("#modalStatus").textContent=(lookupVal(imgMap,k)?"設定済み":"未設定");
  $("#fileInput").value=""; $("#urlInput").value=(cur && !cur.startsWith("data:"))?cur:"";
  imageModal.classList.add("show"); imageModal.setAttribute("aria-hidden","false");
}
function closeImageModal(){ imageModal.classList.remove("show"); imageModal.setAttribute("aria-hidden","true"); if(tempPreviewURL){ URL.revokeObjectURL(tempPreviewURL); tempPreviewURL=""; } }
$("#closeBtn").addEventListener("click", closeImageModal);
imageModal.addEventListener("click",(e)=>{ if(e.target===imageModal) closeImageModal(); });

$("#fileInput").addEventListener("change", async ()=>{
  if(tempPreviewURL){ URL.revokeObjectURL(tempPreviewURL); tempPreviewURL=""; }
  const file=$("#fileInput").files[0]; if(!file){ $("#modalPreview").src=""; return; }
  const kind=getFileKind(file);
  try{
    if(kind==="image"){ tempPreviewURL=URL.createObjectURL(file); $("#modalPreview").src=tempPreviewURL; $("#modalStatus").textContent="未保存のプレビュー（画像）"; return; }
    if(kind==="audio"){ const blob=await makeNotePlaceholder(256); tempPreviewURL=URL.createObjectURL(blob); $("#modalPreview").src=tempPreviewURL; $("#modalStatus").textContent="未保存のプレビュー（音声:♫）"; return; }
    if(kind==="video"){ const thumb=await extractVideoThumbnail(file,{time:0.1,maxSize:256}); tempPreviewURL=URL.createObjectURL(thumb); $("#modalPreview").src=tempPreviewURL; $("#modalStatus").textContent="未保存のプレビュー（動画サムネ）"; return; }
  }catch(e){ const ph=await makeFilmPlaceholder(256); tempPreviewURL=URL.createObjectURL(ph); $("#modalPreview").src=tempPreviewURL; $("#modalStatus").textContent="プレビュー生成に失敗（プレースホルダ）"; }
});
$("#urlInput").addEventListener("input", ()=>{ const url=($("#urlInput").value||"").trim(); if(url){ $("#modalPreview").src=url; $("#modalStatus").textContent="未保存のプレビュー（URL）"; } });

$("#applyBtn").addEventListener("click", async ()=>{
  if(!currentModalTarget) return;
  const k=keyOf(currentModalTarget.gacha,currentModalTarget.rarity,currentModalTarget.code);
  const file=$("#fileInput").files[0]; const url=($("#urlInput").value||"").trim();
  try{
    if(file){
      const kind=getFileKind(file);
      await idbPut(k+"|orig", file);           // オリジナル
      origMap[k] = "idb:" + (k+"|orig");
      let thumbBlob=null;
      if(kind==="image"){ thumbBlob = await compressImage(file,{maxSize:256,typePrefer:["image/webp","image/jpeg"],quality:0.85}); }
      else if(kind==="audio"){ thumbBlob = await makeNotePlaceholder(256); }
      else if(kind==="video"){ thumbBlob = await extractVideoThumbnail(file,{time:0.1,maxSize:256}); }
      await idbPut(k+"|thumb", thumbBlob); imgMap[k]="idb:"+(k+"|thumb");
      saveLocalJSON(LS_KEY_IMG,imgMap); saveLocalJSON(LS_KEY_ORIG,origMap); saveAppStateDebounced();
    }else if(url){
      let ok=false;
      try{
        const resp = await fetch(url,{mode:"cors"}); const blob = await resp.blob();
        await idbPut(k+"|orig", blob); origMap[k] = "idb:"+(k+"|orig");
        const kind = blob.type.startsWith("image/") ? "image" : blob.type.startsWith("video/") ? "video" : blob.type.startsWith("audio/") ? "audio" : "unknown";
        let thumbBlob=null;
        if(kind==="image"){ thumbBlob = await compressImage(blob,{maxSize:256,typePrefer:["image/webp","image/jpeg"],quality:0.85}); }
        else if(kind==="audio"){ thumbBlob = await makeNotePlaceholder(256); }
        else if(kind==="video"){ thumbBlob = await extractVideoThumbnail(blob,{time:0.1,maxSize:256}); }
        if(thumbBlob){ await idbPut(k+"|thumb", thumbBlob); imgMap[k]="idb:"+(k+"|thumb"); ok=true; }
      }catch(_e){}
      if(!ok){ imgMap[k]=url; }
      saveLocalJSON(LS_KEY_IMG,imgMap); saveLocalJSON(LS_KEY_ORIG,origMap); saveAppStateDebounced();
    }else{ alert("ファイルまたはURLを指定してください。"); return; }
    closeImageModal(); renderItemGrid(); renderUsersList(); saveAppStateDebounced();
  }catch(err){ console.error(err); alert("保存に失敗: "+(err?.message||err)); }
});

/* ====== 解除／リアグ ====== */
async function clearImage(it){
  const kNew=keyOf(it.gacha,it.rarity,it.code), kOld=legacyKey(it.rarity,it.code);
  for(const k of [kNew,kOld]){
    const v=imgMap[k]; if(v && v.startsWith("idb:")){ const real=v.slice(4); await idbDelete(real); if(urlCache.has(real)){ URL.revokeObjectURL(urlCache.get(real)); urlCache.delete(real); } }
    const o=origMap[k]; if(o && o.startsWith("idb:")){ await idbDelete(o.slice(4)); }
    delete imgMap[k]; delete origMap[k];
  }
  saveLocalJSON(LS_KEY_IMG,imgMap); saveLocalJSON(LS_KEY_ORIG,origMap);
  renderItemGrid(); renderUsersList(); saveAppStateDebounced();
}
async function toggleSkip(it){ const k=keyOf(it.gacha,it.rarity,it.code); if(skipHas(k)){ skipDel(k); } else { await clearImage(it); skipAdd(k); } renderItemGrid(); }

/* ====== 画像のプレビュー解決 ====== */
async function resolveThumbs(root=document){
  const nodes=$$('[data-thumb-key]',root);
  await Promise.all(nodes.map(async el=>{
    const key=el.getAttribute('data-thumb-key'); if(!key) return;
    if(immediateSrcFor(key)) return;
    const v=lookupVal(imgMap,key); if(v && v.startsWith("idb:")){ const idbKey=v.slice(4); const url=await urlForKey(idbKey); if(url){ el.innerHTML=`<img src="${url}" alt="${escapeHtml(key.split('::')[2]||'item')}" />`; } }
  }));
}

async function resolvePills(root=document){
  const nodes=$$('[data-img-key]',root);
  const showCounts = $("#showCounts")?.checked;

  await Promise.all(nodes.map(async el=>{
    const key=el.dataset.imgKey;
    const v=lookupVal(imgMap,key);
    if(!v) return;

    const user  = el.dataset.user;
    const gacha = el.dataset.gacha;
    const rarity= el.dataset.rarity;
    const code  = el.dataset.code;
    const countVal = showCounts ? (((gHitCounts[user]||{})[gacha]||{})[rarity]||{})[code] : null;
    const labelHtml = `<span>${escapeHtml(code)}</span>${(countVal!=null)?`<span class="count">×${countVal}</span>`:""}`;

    if(v.startsWith("idb:")){
      const url=await urlForKey(v.slice(4));
      if(url){ el.classList.remove("no-img"); el.innerHTML=`<img alt="${escapeHtml(code)}" src="${url}"/>${labelHtml}`; }
    }else{
      el.classList.remove("no-img");
      el.innerHTML=`<img alt="${escapeHtml(code)}" src="${v}"/>${labelHtml}`;
    }
  }));
}

/* ====== ZIP作成（保存用） ====== */
async function buildZipForUser(user, gobj){
  const zip = new JSZip(); const usedNames = new Set(); let count = 0;
  for(const [gacha,info] of Object.entries(gobj)){
    const itemObj = info.items || {};
  for(const rarity of Object.keys(itemObj)){
      for(const code of (itemObj[rarity] || [])){
        const key = keyOf(gacha, rarity, code);
        if(skipHas(key)) continue;
        const blob = await getOriginalBlobForKey(key);
        if(!blob) continue;
        const ext = guessExt(blob.type) || "bin";
        const base = `${sanitize(gacha)}/${rarity}_${sanitize(code)}.${ext}`;
        let name = base, i=2; while(usedNames.has(name)){ name = base.replace(`.${ext}`, `(${i++}).${ext}`); }
        usedNames.add(name);
        zip.file(name, blob, {binary:true, compression:"STORE"});
        count++;
      }
    }
  }
  if(count === 0) throw new Error("出力対象がありません（画像未設定 or すべてリアグ）");
  const blob = await zip.generateAsync({type:"blob", compression:"STORE"});
  return {blob, count, size: blob.size};
}

async function getOriginalBlobForKey(key){
  const orig = origMap[key];
  if(orig && orig.startsWith("idb:")){ const b = await idbGet(orig.slice(4)); if(b) return b; }
  const v = lookupVal(imgMap, key);
  if(v && v.startsWith("idb:")){ const b = await idbGet(v.slice(4)); if(b) return b; }
  if(v && /^https?:|^data:/.test(v)){ try{ const res = await fetch(v,{mode:"cors"}); const b = await res.blob(); return b; }catch(_e){ return null; } }
  return null;
}

const guessExt = (mime) => {
  if(!mime) return "";
  if(mime==="image/jpeg") return "jpg";
  const map = { "image/png":"png","image/webp":"webp","image/gif":"gif","image/svg+xml":"svg",
                "video/mp4":"mp4","video/webm":"webm","audio/mpeg":"mp3","audio/wav":"wav","audio/mp4":"m4a" };
  return map[mime] || (mime.split("/")[1]||"");
};

/* ====== 画像処理補助 ====== */
function getFileKind(file){ const t=(file.type||"").toLowerCase(); const n=(file.name||"").toLowerCase();
  if(t.startsWith("image/")) return "image";
  if(t.startsWith("video/")||n.endsWith(".mp4")||n.endsWith(".webm")||n.endsWith(".mov")) return "video";
  if(t.startsWith("audio/")||n.endsWith(".mp3")||n.endsWith(".wav")||n.endsWith(".m4a")) return "audio";
  return "unknown"; }
async function makeNotePlaceholder(size=256){ const c=document.createElement("canvas"); c.width=c.height=size; const x=c.getContext("2d");
  x.fillStyle="#0e0f14"; x.fillRect(0,0,size,size); x.fillStyle="#1f2937"; x.beginPath(); x.arc(size*.5,size*.5,size*.42,0,Math.PI*2); x.fill();
  x.fillStyle="#e11d48"; x.font=`${Math.round(size*.5)}px system-ui,-apple-system,"Segoe UI",Roboto,"Noto Color Emoji"`; x.textAlign="center"; x.textBaseline="middle"; x.fillText("♫", size*.5, size*.5);
  return await new Promise(r=>c.toBlob(r,"image/png")); }
async function makeFilmPlaceholder(size=256){ const c=document.createElement("canvas"); c.width=c.height=size; const x=c.getContext("2d");
  x.fillStyle="#0e0f14"; x.fillRect(0,0,size,size); x.strokeStyle="#e11d48"; x.lineWidth=Math.max(2,size*.04); x.strokeRect(size*.15,size*.25,size*.7,size*.5);
  for(let i=0;i<4;i++){ x.fillStyle="#1f2937"; x.fillRect(size*(0.18+i*0.18), size*0.18, size*0.08, size*0.05); x.fillRect(size*(0.18+i*0.18), size*0.77, size*0.08, size*0.05); }
  return await new Promise(r=>c.toBlob(r,"image/png")); }
async function extractVideoThumbnail(fileOrBlob,{time=0.1,maxSize=256}={}){ const url=URL.createObjectURL(fileOrBlob);
  try{ const v=document.createElement("video"); v.preload="metadata"; v.src=url; v.muted=true;
    await new Promise((ok,ng)=>{ v.onloadedmetadata=()=>ok(); v.onerror=()=>ng(new Error("metadata load failed")); });
    v.currentTime=Math.min(Math.max(time,0.01),(v.duration||1)-0.01); await new Promise(ok=>{ v.onseeked=()=>ok(); });
    const w=v.videoWidth,h=v.videoHeight,s=Math.min(1,maxSize/Math.max(w,h)); const tw=Math.max(1,Math.round(w*s)), th=Math.max(1,Math.round(h*s));
    const c=document.createElement("canvas"); c.width=tw; c.height=th; c.getContext("2d").drawImage(v,0,0,tw,th); URL.revokeObjectURL(url);
    return await new Promise(r=>c.toBlob(r,"image/webp",0.85));
  }catch(e){ URL.revokeObjectURL(url); return await makeFilmPlaceholder(maxSize); } }
async function compressImage(fileOrBlob,{maxSize=256,typePrefer=["image/webp","image/jpeg"],quality=0.85}={}){
  const img=await createImageBitmap(fileOrBlob).catch(()=>null); const tag=img?null:await fileToImage(fileOrBlob);
  const w=img?img.width:tag.naturalWidth, h=img?img.height:tag.naturalHeight, s=Math.min(1,maxSize/Math.max(w,h));
  const tw=Math.max(1,Math.round(w*s)), th=Math.max(1,Math.round(h*s));
  const c=document.createElement("canvas"); c.width=tw; c.height=th; c.getContext("2d").drawImage(img||tag,0,0,tw,th);
  for(const mime of typePrefer){ const b=await new Promise(r=>c.toBlob(r,mime,quality)); if(b) return b; } return await new Promise(r=>c.toBlob(r,"image/png"));
}
function fileToImage(file){ return new Promise((ok,ng)=>{ const fr=new FileReader(); fr.onload=()=>{ const img=new Image(); img.onload=()=>ok(img); img.onerror=ng; img.src=fr.result; }; fr.onerror=ng; fr.readAsDataURL(file); }); }

/* ====== 開始フロー UI（堅牢版） ====== */
const splash = $("#splash"), mainUI = $("#mainUI");
const startModal = $("#startModal"), catalogModal = $("#catalogModal"),
      liveModal = $("#liveModal"), finalModal = $("#finalModal"),
      guideModal = $("#guideModal");

let modalCount = 0;
function open(modal){
  if (!modal) return;
  modal.classList.add("show");
  modal.setAttribute("aria-hidden","false");
  if (++modalCount === 1) document.body.classList.add("modal-open");
}
function close(modal){
  if (!modal || !modal.classList.contains("show")) return;
  modal.classList.remove("show");
  modal.setAttribute("aria-hidden","true");
  if (--modalCount <= 0){ modalCount = 0; document.body.classList.remove("modal-open"); }
}
function startDone(){
  if (splash) splash.style.display = "none";
  if (mainUI) mainUI.style.display = "block";
  document.body.classList.remove('splash-locked');
  close(startModal);
}

/* ▼ DOM構築後に安全にバインド */
document.addEventListener('DOMContentLoaded', () => {
  $("#openStart")?.addEventListener("click", ()=> open(startModal));
  $("#closeStart")?.addEventListener("click", ()=> close(startModal));

  $("#tileJson")?.addEventListener("click", ()=> $("#jsonFile2")?.click());
  $("#tileTxt")?.addEventListener("click",  ()=> $("#txtFileInput")?.click());
  $("#tileLive")?.addEventListener("click", ()=> open(catalogModal));
  $("#tileFinal")?.addEventListener("click", ()=> open(finalModal));

  $("#jsonFile2")?.addEventListener("change", ()=>{
    const inp = $("#jsonFile2");
    const f = inp?.files?.[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = () => {
      try {
        onJsonLoaded(JSON.parse(rd.result));
        startDone();
      } catch (err) {
        alert("JSONの解析に失敗: " + (err?.message || err));
      } finally {
        if (inp) inp.value = "";
      }
    };
    rd.readAsText(f, "utf-8");

  });

  $("#catClose").addEventListener("click", ()=>close(catalogModal));
  $("#openLivePaste").addEventListener("click", ()=>open(liveModal));
  $("#liveClose").addEventListener("click", ()=>close(liveModal));
  $("#finalClose").addEventListener("click", ()=>close(finalModal));


  // TXT(.txt) を選択 → base64(raw deflate) → JSON → 取り込み
  $("#txtFileInput")?.addEventListener("change", async (ev)=>{
    const inp = ev.currentTarget;
    const f = ev.target.files?.[0]; if (!f) return;
    try{
      if (typeof pako === "undefined") throw new Error("pako が読み込まれていません。");
      const b64 = (await f.text()).trim();
      const bytes = b64ToBytes(b64);                 // ※ URL-safe/改行除去版を使用
      const jsonStr = pako.inflateRaw(bytes, { to: "string" }); // ★ raw が必須
      const state = JSON.parse(jsonStr);
      await importFromExternalState(state);          // ※ この中で startDone() 済み
    }catch(err){
      console.error(err);
      alert("TXTの復元に失敗しました: " + (err?.message || err));
    }finally{
      if (inp) inp.value = ""; // 同じファイルを連続選択可
    }
  });
});

document.addEventListener('DOMContentLoaded', () => {
  const tabsWrap = document.getElementById('gachaTabs');
  if (tabsWrap && !tabsWrap.__boundPointer) {
    tabsWrap.addEventListener('pointerdown', (e) => {
      const t = e.target.closest('.tab');
      if (!t || t.classList.contains('add')) return;      // “＋”タブは除外
      const g = t.dataset.gacha;
      if (!g) return;
      // 既存の選択処理をそのまま流用
      selectedGacha = g;
      $$(".tab", tabsWrap).forEach(x => x.classList.toggle("active", x.dataset.gacha === g));
      renderItemGrid();
      e.preventDefault(); // 300ms遅延/ゴーストクリックを抑止
    }, { passive:false });
    tabsWrap.__boundPointer = true;
  }
});


/* ====== 1) リアルタイム：カタログ解析 → 反映 ====== */
$("#catParse").addEventListener("click", ()=>{
  const gacha = ($("#catGachaName").value||"").trim() || "ガチャ";
  const text  = ($("#catText").value||"").trim();
  if(!text){ alert("テキストを貼り付けてください。"); return; }
  const items = parseCatalogText(text);
  if(items.length===0){ alert("アイテムを検出できませんでした。入力形式をご確認ください。"); return; }
  // 反映：カタログとして登録
  const arr = [];
  items.forEach(({rarity, code})=>{
    arr.push({gacha, rarity, code});
  });
  gCatalogByGacha[gacha] = arr;
  selectedGacha = gacha;
  rebuildGachaCaches(); renderTabs(); renderItemGrid(); // ユーザーは空でもOK
  startDone(); close(catalogModal);
  // 次：ライブ貼り付けを促す
  open(guideModal);
});

/* ====== 1.5) ガイドモーダルを閉じる ====== */
$("#guideOk").addEventListener("click", ()=>close(guideModal));

/* ====== 2) リアルタイム：結果貼り付け（繰り返し可） ====== */
$("#liveApply").addEventListener("click", () => {
  const text = ($("#liveText").value || "").trim();
  if (!text) { alert("テキストを貼り付けてください。"); return; }

  const blocks = splitLiveBlocks(text);
  if (blocks.length === 0) { alert("解析できるブロックが見つかりませんでした。"); return; }

  const delta = {};
  let lastGacha = null;
  let added = 0;

  for (const block of blocks) {
    const parsed = parseLiveBlock(block);
    if (!parsed) continue;

    const { gacha, user, pulls, items } = parsed;
    lastGacha = gacha;

    // deltaに積む
    delta[user] = delta[user] || {};
    delta[user][gacha] = delta[user][gacha] || { pulls: 0, items: {} };
    delta[user][gacha].pulls += pulls;

    // 獲得数（counts）を加算
    if (parsed.counts) {
      for (const [rarity, byCode] of Object.entries(parsed.counts)) {
        for (const [code, num] of Object.entries(byCode)) {
          incCount(user, gacha, rarity, code, num);
        }
      }
    }

    for (const [rarity, codes] of Object.entries(items)) {
      delta[user][gacha].items[rarity] = delta[user][gacha].items[rarity] || [];
      codes.forEach(c => { if (!delta[user][gacha].items[rarity].includes(c)) delta[user][gacha].items[rarity].push(c); });
    }

    // カタログも更新（未登録アイテムの補完）
    const cat = gCatalogByGacha[gacha] || [];
    const map = new Map(cat.map(it => [ `${it.gacha}::${it.rarity}::${it.code}`, it ]));
    Object.entries(items).forEach(([rarity, codes]) => {
      codes.forEach(code => {
        const k = `${gacha}::${rarity}::${code}`;
        if (!map.has(k)) map.set(k, { gacha, rarity, code });
      });
    });
    gCatalogByGacha[gacha] = Array.from(map.values()).sort(byRarityThenCode);

    added++;
  }

  if (!added) { alert("ブロックは見つかりましたが、解析に失敗しました。形式をご確認ください。"); return; }

  // gDataへマージ → 再描画
  mergeIntoGData(delta);
  if (lastGacha) selectedGacha = lastGacha;

  $("#liveText").value = "";
  close(liveModal);          // ← 反映後にモーダルを閉じる
  startDone();               // ← まだスプラッシュ表示なら通常画面へ
  rebuildGachaCaches();
  renderTabs();
  renderItemGrid();
  renderUsersList();
  saveAppStateDebounced();
});

/* ====== 3) 最終結果：一括貼り付け → 反映 ====== */
$("#finalParse").addEventListener("click", ()=>{
  const gacha = ($("#finalGachaName").value||"").trim() || "ガチャ";
  const text = ($("#finalText").value||"").trim();
  if(!text){ alert("テキストを貼り付けてください。"); return; }
  const parsed = parseFinalSummaryText(text);
  if(parsed.length===0){ alert("ユーザーの成績を検出できませんでした。"); return; }

  const delta = {}, catSet = new Map();
  parsed.forEach(({user, entries})=>{
    delta[user] = delta[user] || {};
    delta[user][gacha] = delta[user][gacha] || {pulls:0, items:{}};
    let pulls = 0;
    entries.forEach(({rarity, code, count})=>{
      pulls += (+count||0);
      delta[user][gacha].items[rarity] = delta[user][gacha].items[rarity] || [];
      uniqPush(delta[user][gacha].items[rarity], code);
      catSet.set(keyOf(gacha,rarity,code), {gacha,rarity,code});
      incCount(user, gacha, rarity, code, +count||0);
    });
    delta[user][gacha].pulls += pulls;
  });

  // カタログ反映
  gCatalogByGacha[gacha] = Array.from(catSet.values()).sort(byRarityThenCode);

  mergeIntoGData(delta);
  rebuildGachaCaches(); renderTabs(); renderItemGrid(); renderUsersList();
  startDone(); close(finalModal); saveAppStateDebounced();
});

/* ====== マージ/ユーティリティ ====== */
function mergeIntoGData(delta){
  for(const [user,gobj] of Object.entries(delta)){
    gData[user] = gData[user] || {};
    for(const [gacha,info] of Object.entries(gobj)){
      gData[user][gacha] = gData[user][gacha] || {pulls:0, items:{}};
      gData[user][gacha].pulls += (info.pulls||0);
      for(const [rarity,codes] of Object.entries(info.items||{})){
        gData[user][gacha].items[rarity] = gData[user][gacha].items[rarity] || [];
        codes.forEach(c=>uniqPush(gData[user][gacha].items[rarity], c));
      }
    }
  }
  saveAppStateDebounced();
}

/* ====== 解析: 出現アイテム一覧 ======
   行の並びが ①タブ区切り（1\tR\t7.5%\tC）
            または ②縦4行（1 / R / 7.5% / C） を両対応 */
function parseCatalogText(text){
  const items = [];
  const clean = text.replace(/\r/g,'').replace(/[ \t]+\n/g,'\n').trim();
  // ① タブ区切り
  const reTab = /^\s*\d+\s*\t\s*([^\t]+)\t([^\t\n]+)\t([^\t\n]+)\s*$/gm;
  let m;
  while((m = reTab.exec(clean)) !== null){
    const rarity=(m[1]||"").trim(); const code=(m[3]||"").trim();
    if(rarity) items.push({rarity, code});
  }
  if(items.length>0) return items;

  // ② 縦4行
  const lines = clean.split(/\n+/);
  // ヘッダ除去
  while(lines.length && /No\./.test(lines[0])) lines.shift();
  while(lines.length && /レアリティ|景品名|出現率/.test(lines[0])) lines.shift();

  for(let i=0;i+3<lines.length;i++){
    const a=lines[i].trim(), b=lines[i+1].trim(), c=lines[i+2].trim(), d=lines[i+3].trim();
    if(/^\d+$/.test(a) && b && d){ items.push({rarity:b, code:d}); i+=3; }
  }
  return items;
}

/* ====== 解析: リアルタイム結果（1ブロック） ====== */
function splitLiveBlocks(text){
  const clean = text.replace(/\r/g, '').trim();
  // 「#なまずつーるず」(末尾に空白があっても可) だけを区切りに採用
  return clean
    .split(/#なまずつーるず[^\S\r\n]*/g)
    .map(s => s.trim())
    .filter(Boolean);
}
function parseLiveBlock(block){
  const lines = block.split(/\n+/).map(s=>s.trim()).filter(Boolean);
  if(lines.length<3) return null;
  const gacha = lines[0];
  const mUser = /^(.+?)\s*([0-9]+)\s*連$/.exec(lines[1]);
  if(!mUser) return null;
  const user = mUser[1].trim(); const pulls = parseInt(mUser[2],10)||0;
  const items = {};
  const counts = {}; // counts[rarity][code] = number

  for(let i=2;i<lines.length;i++){
    const line = lines[i];
    const m = /【([^】]+)】\s*([^\s　]+)[\s　]+(\d+)個?/.exec(line);
    if(!m) continue;
    const rarity=m[1].trim(), code=m[2].trim(), num=parseInt(m[3],10)||0;
    items[rarity]=items[rarity]||[]; if(!items[rarity].includes(code)) items[rarity].push(code);
    counts[rarity]=counts[rarity]||{}; counts[rarity][code]=(counts[rarity][code]||0)+num;
  }
  return {gacha,user,pulls,items,counts};
}

/* ====== 解析: 最終結果一覧 ======
   構造： (数字) → (ユーザー名) → 多数の「番号\tレアリティ\t景品\t個数」行 → 次の (数字) ... */
function parseFinalSummaryText(text){
  const lines = text.replace(/\r/g,'').split(/\n/).map(s=>s.trim());
  const out = [];
  // ヘッダをスキップ
  let i=0; while(i<lines.length && (/^ガチャ$/.test(lines[i]) || /^No\./.test(lines[i]) || /名前$/.test(lines[i]) || /レアリティ/.test(lines[i]))) i++;
  while(i<lines.length){
    // 数字行
    if(!/^\d+$/.test(lines[i]||"")){ i++; continue; }
    i++;
    const user = (lines[i++]||"").trim(); if(!user){ continue; }
    const entries=[];
    while(i<lines.length){
      const s=lines[i];
      if(/^\d+$/.test(s)) break;  // 次ユーザー
      const m=/^\s*\d+\s*\t\s*([^\t]+)\t([^\t]+)\t(\d+)\s*$/.exec(s);
      if(m){ entries.push({rarity:m[1].trim(), code:m[2].trim(), count:parseInt(m[3],10)||0}); i++; }
      else { i++; }
    }
    if(entries.length) out.push({user, entries});
  }
  return out;
}

/* ====== フィルタ＆その他イベント ====== */
$("#filterGacha").addEventListener("change", renderUsersList);
$("#filterRarity").addEventListener("change", ()=>{ renderItemGrid(); renderUsersList(); });
$("#hideMiss").addEventListener("change", renderUsersList);
$("#userSearch").addEventListener("input", renderUsersList);
$("#showCounts")?.addEventListener("change", renderUsersList);
$("#showSkipOnly")?.addEventListener("change", renderUsersList);

$("#exportMapBtn").addEventListener("click", async ()=>{
  const bundle={ images:imgMap, skip:Array.from(skipSet), original:origMap };
  const blob=new Blob([JSON.stringify(bundle,null,2)],{type:"application/json"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="gacha_image_map_bundle.json"; document.body.appendChild(a); a.click(); a.remove();
});
$("#importMapInput").addEventListener("change", ()=>{
  const f=$("#importMapInput").files[0]; if(!f) return;
  const fr=new FileReader(); fr.onload=()=>{ try{
    const json=JSON.parse(fr.result);
    if(json.images&&typeof json.images==="object") imgMap=json.images; else if(typeof json==="object" && !json.original){ imgMap=json; }
    if(Array.isArray(json.skip)) skipSet=new Set(json.skip);
    if(json.original && typeof json.original==="object") origMap=json.original;
    saveLocalJSON(LS_KEY_IMG,imgMap); saveLocalJSON(LS_KEY_SKIP,Array.from(skipSet)); saveLocalJSON(LS_KEY_ORIG,origMap);
    renderItemGrid(); renderUsersList();
  }catch(e){ alert("画像マップの読み込みに失敗: "+e.message); } };
  fr.readAsText(f,"utf-8");
});
$("#clearMapBtn").addEventListener("click", async ()=>{
  if(confirm("ローカルの画像マップ/オリジナル/リアグ設定を削除します。よろしいですか？")){
    imgMap={}; origMap={}; skipSet=new Set();
    saveLocalJSON(LS_KEY_IMG,imgMap); saveLocalJSON(LS_KEY_ORIG,origMap); saveLocalJSON(LS_KEY_SKIP,[]);
    await idbClear(); for(const url of urlCache.values()) URL.revokeObjectURL(url); urlCache.clear();
    renderItemGrid(); renderUsersList();
  }
});

if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const reg = await navigator.serviceWorker.register('/sw.js', { type: 'module' });

      // ★ ページ表示時・可視化時・定期的にアップデートチェック
      reg.update();
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') reg.update();
      });
      setInterval(() => reg.update(), 60 * 60 * 1000); // 1時間おき

      // ★ 新SWが waiting になったら即座に skipWaiting を依頼
      reg.addEventListener('updatefound', () => {
        const sw = reg.installing;
        if (!sw) return;
        sw.addEventListener('statechange', () => {
          if (sw.state === 'installed' && navigator.serviceWorker.controller) {
            sw.postMessage({ type: 'SKIP_WAITING' });
          }
        });
      });

      // ★ controller が切り替わったら自動リロード（1回だけ）
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return;
        refreshing = true;
        // SPA の状態保持が必要なら、ここで軽いダイアログを挟むのも可
        window.location.reload();
      });

      // 受信ログ（任意）
      navigator.serviceWorker.addEventListener('message', (ev) => {
        if (ev.data?.type === 'SW_ACTIVATED') {
          console.log('[SW] activated:', ev.data.version);
        }
      });
    } catch (e) {
      console.warn('SW registration failed', e);
    }
  });
}

// --- TXT(base64 + DEFLATE raw) を復元して取り込む ---

// base64 → Uint8Array（URL-safe/改行を除去）
function b64ToBytes(b64){
  const s = (b64||"").replace(/\s+/g,'').replace(/-/g,'+').replace(/_/g,'/');
  const pad = s.length % 4 ? 4 - (s.length % 4) : 0;
  const bin = atob(s + '='.repeat(pad));
  const arr = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
  return arr;
}

// 外部state(JSON) → 既存構造へ取り込み
async function importFromExternalState(state){
  try{
    // 1) ガチャ名の決定
    const nameMap = state?.gacha_name_list || {};
    const selKey  = String(state?.gacha_select ?? Object.keys(nameMap)[0] ?? "0");
    const gacha   = nameMap[selKey] || "ガチャ";

    // 2) カタログ（item_base × rarity_base）
    const rarityBase = Array.isArray(state?.gacha_data?.rarity_base) ? state.gacha_data.rarity_base : [];
    // 位置インデックス → レア名（例: 0->"N"）
    const rarityIdxToName = rarityBase.map(row => Array.isArray(row) ? String(row[0]) : String(row?.name||""));
    const itemBase = Array.isArray(state?.gacha_data?.item_base) ? state.gacha_data.item_base : [];

    const cat = [];
    for(const row of itemBase){
      // 形式: [rarityIndex, weight, itemName]
      const ridx = parseInt(row?.[0],10);
      const code = String(row?.[2] ?? "");
      if(!code) continue;
      const rarity = rarityIdxToName[ridx] || String(row?.[1] ?? "N"); // 念のためフォールバック
      cat.push({ gacha, rarity, code });
    }
    if(cat.length) gCatalogByGacha[gacha] = cat.sort(byRarityThenCode);

    // 3) 履歴（history_list）
    // 形式: [ [ userName, [ [itemId, rarityStr, itemName, count], ... ] ], ... ]
    const hist = Array.isArray(state?.gacha_data?.history_list) ? state.gacha_data.history_list : [];
    const delta = {};
    for(const pair of hist){
      const user  = String(pair?.[0] ?? "");
      const entries = Array.isArray(pair?.[1]) ? pair[1] : [];
      if(!user || !entries.length) continue;

      delta[user] = delta[user] || {};
      delta[user][gacha] = delta[user][gacha] || { pulls: 0, items: {} };

      let pulls = 0;
      for(const e of entries){
        // e: [id, rarity, itemName, count]
        const rarity = String(e?.[1] ?? "");
        const code   = String(e?.[2] ?? "");
        const n      = +e?.[3] || 0;
        if(!rarity || !code) continue;

        // items: 種類（ユニーク）
        const arr = (delta[user][gacha].items[rarity] ||= []);
        if(!arr.includes(code)) arr.push(code);

        // 獲得数＆pulls
        incCount(user, gacha, rarity, code, n);
        pulls += n;

        // カタログ補完（history にしか無い名称も拾う）
        if(!gCatalogByGacha[gacha]){
          gCatalogByGacha[gacha] = [{gacha,rarity,code}];
        }else{
          const k = keyOf(gacha,rarity,code);
          // 既存に無ければ追加
          if(!(gCatalogByGacha[gacha].some(it => keyOf(it.gacha,it.rarity,it.code) === k))){
            gCatalogByGacha[gacha].push({gacha,rarity,code});
          }
        }
      }
      delta[user][gacha].pulls += pulls;
    }

    if(Object.keys(delta).length){
      // カタログのソート
      if(Array.isArray(gCatalogByGacha[gacha])) {
        gCatalogByGacha[gacha].sort(byRarityThenCode);
      }
      // マージ→再描画
      mergeIntoGData(delta);
    }

    rebuildGachaCaches(); renderTabs(); renderItemGrid(); renderUsersList();  
    startDone(); close(startModal); saveAppStateDebounced();
  }catch(err){
    console.error(err);
    alert("取り込みに失敗しました: " + (err?.message || err));
  }
}
/* --- PWA(standalone) × モバイル端末のみで、ズーム挙動を抑止 --- */
(function () {
  // “モバイル相当”かつ PWA(standalone) 判定
  const isMobile =
    window.matchMedia('(max-width: 900px), (hover: none) and (pointer: coarse)').matches;
  const isStandalone =
    window.matchMedia('(display-mode: standalone)').matches || // PWA（多くのブラウザ）
    (typeof navigator.standalone === 'boolean' && navigator.standalone === true); // iOS Safari

  if (!isMobile || !isStandalone) return;

  // 入力系はズーム抑止の対象外
  const isInteractive = (el) =>
    !!el.closest('input, textarea, select, button, [role="button"], [contenteditable="true"], .allow-zoom, .tab, #gachaTabs');

  // ダブルタップズーム抑止
  let lastTouchEnd = 0;
  document.addEventListener(
    'touchend',
    (e) => {
      if (isInteractive(e.target)) return;
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    },
    { passive: false }
  );

  // ピンチズーム抑止（2本指開始をキャンセル）
  document.addEventListener(
    'touchstart',
    (e) => {
      if (isInteractive(e.target)) return;
      if (e.touches.length > 1) e.preventDefault();
    },
    { passive: false }
  );
})();

</script>
<script>
/* App⇔モジュールのブリッジ（let 変数を window へ安全に受け渡す） */
window.AppStateBridge = {
  getState(){
    return {
      gData, gCatalogByGacha, gHitCounts, selectedGacha,
      imgMap, origMap, skipArray: Array.from(skipSet || [])
    };
  },
  setState(st){
    gData = st.gData || {};
    gCatalogByGacha = st.gCatalogByGacha || {};
    gHitCounts = st.gHitCounts || {};
    selectedGacha = st.selectedGacha || null;
    imgMap = st.imgMap || {};
    origMap = st.origMap || {};
    skipSet = new Set(st.skipArray || []);
  },
  afterRestore(){
    // 既存の保存キーと整合（存在しなければデフォルト）
    const K_IMG  = window.LS_KEY_IMG  || 'gacha_item_image_map_v1';
    const K_ORIG = window.LS_KEY_ORIG || 'gacha_item_original_v1';
    const K_SKIP = window.LS_KEY_SKIP || 'gacha_item_image_skip_v1';
    try{
      localStorage.setItem(K_IMG,  JSON.stringify(imgMap));
      localStorage.setItem(K_ORIG, JSON.stringify(origMap));
      localStorage.setItem(K_SKIP, JSON.stringify(Array.from(skipSet)));
    }catch(e){}

    // 画面更新（既存実装があれば呼ぶ）
    if (typeof rebuildGachaCaches === 'function') rebuildGachaCaches();
    if (typeof renderTabs        === 'function') renderTabs();
    if (typeof renderItemGrid    === 'function') renderItemGrid();
    if (typeof renderUsersList   === 'function') renderUsersList();
    if (typeof startDone         === 'function') startDone();
  }
};

document.addEventListener('DOMContentLoaded', () => {
  const exBtn = document.getElementById('exportAllBtn');
  const imp   = document.getElementById('importAllInput');

  exBtn?.addEventListener('click', async (e) => {
    await window.ImpExp?.exportAllZip(e.currentTarget).catch(err => alert("エクスポート失敗: " + (err?.message || err))); // 第二引数はボタン（任意）
  });

  imp?.addEventListener('change', (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  importAllZip(f).catch(err => alert("インポート失敗: " + (err?.message || err)))
    .finally(()=>{ e.target.value = ""; });
  });
});
</script>
</body>
</html>
