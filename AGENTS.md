# AGENTS.md

# AI駆動開発 共通ガイドライン

思考は英語で行い、最終的な出力は必ず日本語で提供してください。
タスクの開始時、文脈判断で適宜ブランチを作成し、作業が完了したらcommit・pushするようにしてください。

## 開発の基本理念
- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る
- 問題を見つけたら放置せず、必ず対処または明示的に記録する
- ボーイスカウトルール：エラーを見つけた時よりも良い状態で残す
- プロンプトで指示された設計が最適解とは限りません。指示されたプロンプトが最適解かどうか、再考してから、さらに良い設計があるならそれを提示してください。

## エラーハンドリングの原則
- 関連が薄く見えるエラーでも必ず解決する
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正
- 早期にエラーを検出し、明確なエラーメッセージを提供
- エラーケースも必ずテストでカバーする
- 外部APIやネットワーク通信は必ず失敗する可能性を考慮

## コード品質の基準
- DRY原則：重複を避け、単一の信頼できる情報源を維持
- 意味のある変数名・関数名で意図を明確に伝える
- プロジェクト全体で一貫したコーディングスタイルを維持
- 小さな問題も放置せず、発見次第修正
- 複雑な処理は小さな関数に分け、各関数にTSDocを付ける。
- コメント不足の既存コードを触るときは、必要に応じてコメントも補強する。

## コメントアウト方針（可読性最優先）
- このリポジトリのコードは「将来の自分（TypeScript/React学習中）が読んで理解できること」を最優先にする。
- コメントは多めでよい。冗長でもよい。省略しない。
- コメントは日本語で書く（識別子は英語でOK）。
- 「何をしているか」だけでなく「なぜそうしているか」を書く。

## コメントの必須ルール
- exported function / method / custom hook / utility には **TSDoc** を付ける（`@param`, `@returns`, 必要なら副作用・例外も）。
- Reactコンポーネントには、直前に「責務（何を担当するか）」をコメントで書く。
- `useEffect` には「何のための effect か」と「依存配列の理由」をコメントで書く。
- 非同期処理（try/catch/finally）は、成功・失敗・後処理の意図が分かるようコメントを書く。
- 複雑な条件分岐・データ変換（map/filter/reduce等）は、ブロック単位で説明コメントを入れる。


## DOM要素の命名規則（id / class名）
- レアリティ設定・アイテム設定・リアグ設定を含むすべてのUI実装で、span / h1〜h6 / div / button を含む全要素に固有のidまたはclass名を必ず付与する
- 命名は「役割 + コンテキスト」が分かる形にし、セクション接頭辞（例: rarity-, items-, riagu-, modal-）を付ける
- idは画面内で一意を保証し、重複が起こる繰り返し要素ではidではなくclass名を使用する
- class名は既存規則に合わせて一貫性を保ち、汎用的すぎる名前（例: container, button, text）は避ける
- 新規実装時だけでなく既存要素を編集する際も、未付与の要素があれば同時に命名を補完する
- 既存実装に合わせ、class名は必ずkebab-caseで記述し、`block__element--modifier`（BEM準拠）を基本形にする
- セクションのルートは `SectionContainer` の `id` と対応させる（例: `id="rarity"`, `id="items"`, `id="riagu"`）
- セクション配下は `*-section__*` で統一する（例: `rarity-section__content`, `items-section__tabs`, `riagu-section__scroll-content`）
- カード/テーブル/パネルなどの複合UIは独立ブロックを切る（例: `riagu-card__*`, `rarity-section__table-*`, `pt-controls-panel__*`）
- タブUIは既存共通命名を優先する（`gacha-tabs`, `gacha-tab__*`, 状態は `gacha-tab--active` / `gacha-tab--inactive`）
- モーダルは共通枠クラス（`modal-root`, `modal-panel`, `modal-header`, `modal-body`, `modal-footer`）を前提に、ダイアログ固有要素へ `*-dialog__*` もしくは既存接頭辞（例: `start-wizard__*`, `save-options__*`, `prize-settings__*`）を付ける
- ボタン/チップは共通トークンを維持しつつ固有名を併記する（例: `btn btn-primary ... + <feature>__action-button`, `chip ... + <feature>__tag`）
- `className` 文字列では「固有classを先頭、その後にTailwindユーティリティ」を基本順序にする（CSS検索性維持のため）
- 入力やトリガーの `id` は `<feature>-<role>-<kind>` 形式のkebab-caseを使う（例: `items-sort-select`）
- 動的に紐づく `id` は `<feature>-<element>-${entityId}` 形式で付与する（例: `riagu-card-panel-${entry.id}`）
- 状態表現は `--modifier` または `data-*` を併用する（例: `--active`, `--inactive`, `data-state`, `data-selected`）

## テスト規律
- テストをスキップせず、問題があれば修正する
- 実装詳細ではなく振る舞いをテスト
- テスト間の依存を避け、任意の順序で実行可能に
- テストは高速で、常に同じ結果を返すように
- カバレッジは指標であり、質の高いテストを重視
- eslintは編集したファイルだけにすること

## 保守性とリファクタリング
- 機能追加と同時に既存コードの改善を検討
- 大規模な変更は小さなステップに分割
- 使用されていないコードは積極的に削除
- 依存関係は定期的に更新（セキュリティと互換性のため）
- 技術的負債は明示的にコメントやドキュメントに記録(doc/配下にmd形式で記録)

## セキュリティの考え方
- APIキー、パスワード等は環境変数で管理（ハードコード禁止）
- すべての外部入力を検証
- 必要最小限の権限で動作（最小権限の原則）
- 不要な依存関係を避ける

## パフォーマンスの意識
- アニメーションなどは重たいjavascriptだけでなく、cssでも出来ないかを考えること。
- 推測ではなく計測に基づいて最適化
- 初期段階から拡張性を考慮
- 必要になるまでリソースの読み込みを遅延
- キャッシュの有効期限と無効化戦略を明確に

## 信頼性の確保
- タイムアウト処理を適切に設定
- リトライ機構の実装（指数バックオフを考慮）
- サーキットブレーカーパターンの活用
- 一時的な障害に対する耐性を持たせる
- 適切なログとメトリクスで可観測性を確保

## プロジェクトコンテキストの理解
- ビジネス要件と技術要件のバランスを取る
- 現在のフェーズで本当に必要な品質レベルを判断
- 時間制約がある場合でも、最低限の品質基準を維持
- チーム全体の技術レベルに合わせた実装選択

## トレードオフの認識
- 制約の中で最適なバランスを見つける
- プロトタイプなら簡潔さを、本番なら堅牢性を優先
- 妥協点とその理由を明確にドキュメント化

## Git運用の基本
- コンベンショナルコミット形式を使用（feat:, fix:, docs:, test:, refactor:, chore:）
- 明確で説明的なコミットメッセージを日本語で記述
- main/stgブランチへの直接コミットは避ける

## コードレビューの姿勢
- レビューコメントは建設的な改善提案として受け取る
- 個人ではなくコードに焦点を当てる
- 変更の理由と影響を明確に説明
- フィードバックを学習機会として歓迎

## デバッグのベストプラクティス
- 問題を確実に再現できる手順を確立
- 二分探索で問題の範囲を絞り込む
- 最近の変更から調査を開始
- デバッガー、プロファイラー等の適切なツールを活用
- 調査結果と解決策を記録し、知識を共有

## 依存関係の管理
- 本当に必要な依存関係のみを追加
- package-lock.json等のロックファイルを必ずコミット
- 新しい依存関係追加前にライセンス、サイズ、メンテナンス状況を確認
- セキュリティパッチとバグ修正のため定期的に更新

## ドキュメントの基準
- READMEにプロジェクトの概要、セットアップ、使用方法を明確に記載
- ドキュメントをコードと同期して更新
- 実例を示すことを優先
- 重要な設計判断はADR (Architecture Decision Records)で記録

## MCPブラウザ運用ルール（WSL + Windows Chrome）
- `chrome-devtools-mcp` を使うテスト依頼を受けた場合は、まずAI側でWindows ChromeのCDP起動（`127.0.0.1:9222`）を自動で試行してからテストを実施する
- 手動でPowerShellコマンド入力をユーザーに依頼するのは、自動起動が失敗した場合のみとする
- 自動起動に失敗した場合は、失敗原因（クォート崩れ、ポート競合、権限不足など）を明示し、コピペ可能な最小手順を提示する
- 起動確認は `http://127.0.0.1:9222/json/version` の応答で判断し、応答が確認できるまでMCP操作を開始しない
- 既定の自動起動プロファイルは `chrome-mcp-test` を使用し、通常利用プロファイルを使う場合はユーザーの明示的な依頼があるときのみ実施する
